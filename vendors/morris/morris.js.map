{"version":3,"sources":["build/node_modules/browser-pack/_prelude.js","build/node_modules/morris.js/morris.js","build/vendors/morris/build/vendors/morris/morris.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACp2DA,QAAQ,kBAAR","file":"morris.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* @license\nmorris.js v0.5.0\nCopyright 2014 Olly Smith All rights reserved.\nLicensed under the BSD-2-Clause License.\n*/\n\n\n(function() {\n  var $, Morris, minutesSpecHelper, secondsSpecHelper,\n    __slice = [].slice,\n    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  Morris = window.Morris = {};\n\n  $ = jQuery;\n\n  Morris.EventEmitter = (function() {\n    function EventEmitter() {}\n\n    EventEmitter.prototype.on = function(name, handler) {\n      if (this.handlers == null) {\n        this.handlers = {};\n      }\n      if (this.handlers[name] == null) {\n        this.handlers[name] = [];\n      }\n      this.handlers[name].push(handler);\n      return this;\n    };\n\n    EventEmitter.prototype.fire = function() {\n      var args, handler, name, _i, _len, _ref, _results;\n      name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n      if ((this.handlers != null) && (this.handlers[name] != null)) {\n        _ref = this.handlers[name];\n        _results = [];\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          handler = _ref[_i];\n          _results.push(handler.apply(null, args));\n        }\n        return _results;\n      }\n    };\n\n    return EventEmitter;\n\n  })();\n\n  Morris.commas = function(num) {\n    var absnum, intnum, ret, strabsnum;\n    if (num != null) {\n      ret = num < 0 ? \"-\" : \"\";\n      absnum = Math.abs(num);\n      intnum = Math.floor(absnum).toFixed(0);\n      ret += intnum.replace(/(?=(?:\\d{3})+$)(?!^)/g, ',');\n      strabsnum = absnum.toString();\n      if (strabsnum.length > intnum.length) {\n        ret += strabsnum.slice(intnum.length);\n      }\n      return ret;\n    } else {\n      return '-';\n    }\n  };\n\n  Morris.pad2 = function(number) {\n    return (number < 10 ? '0' : '') + number;\n  };\n\n  Morris.Grid = (function(_super) {\n    __extends(Grid, _super);\n\n    function Grid(options) {\n      this.resizeHandler = __bind(this.resizeHandler, this);\n      var _this = this;\n      if (typeof options.element === 'string') {\n        this.el = $(document.getElementById(options.element));\n      } else {\n        this.el = $(options.element);\n      }\n      if ((this.el == null) || this.el.length === 0) {\n        throw new Error(\"Graph container element not found\");\n      }\n      if (this.el.css('position') === 'static') {\n        this.el.css('position', 'relative');\n      }\n      this.options = $.extend({}, this.gridDefaults, this.defaults || {}, options);\n      if (typeof this.options.units === 'string') {\n        this.options.postUnits = options.units;\n      }\n      this.raphael = new Raphael(this.el[0]);\n      this.elementWidth = null;\n      this.elementHeight = null;\n      this.dirty = false;\n      this.selectFrom = null;\n      if (this.init) {\n        this.init();\n      }\n      this.setData(this.options.data);\n      this.el.bind('mousemove', function(evt) {\n        var left, offset, right, width, x;\n        offset = _this.el.offset();\n        x = evt.pageX - offset.left;\n        if (_this.selectFrom) {\n          left = _this.data[_this.hitTest(Math.min(x, _this.selectFrom))]._x;\n          right = _this.data[_this.hitTest(Math.max(x, _this.selectFrom))]._x;\n          width = right - left;\n          return _this.selectionRect.attr({\n            x: left,\n            width: width\n          });\n        } else {\n          return _this.fire('hovermove', x, evt.pageY - offset.top);\n        }\n      });\n      this.el.bind('mouseleave', function(evt) {\n        if (_this.selectFrom) {\n          _this.selectionRect.hide();\n          _this.selectFrom = null;\n        }\n        return _this.fire('hoverout');\n      });\n      this.el.bind('touchstart touchmove touchend', function(evt) {\n        var offset, touch;\n        touch = evt.originalEvent.touches[0] || evt.originalEvent.changedTouches[0];\n        offset = _this.el.offset();\n        return _this.fire('hovermove', touch.pageX - offset.left, touch.pageY - offset.top);\n      });\n      this.el.bind('click', function(evt) {\n        var offset;\n        offset = _this.el.offset();\n        return _this.fire('gridclick', evt.pageX - offset.left, evt.pageY - offset.top);\n      });\n      if (this.options.rangeSelect) {\n        this.selectionRect = this.raphael.rect(0, 0, 0, this.el.innerHeight()).attr({\n          fill: this.options.rangeSelectColor,\n          stroke: false\n        }).toBack().hide();\n        this.el.bind('mousedown', function(evt) {\n          var offset;\n          offset = _this.el.offset();\n          return _this.startRange(evt.pageX - offset.left);\n        });\n        this.el.bind('mouseup', function(evt) {\n          var offset;\n          offset = _this.el.offset();\n          _this.endRange(evt.pageX - offset.left);\n          return _this.fire('hovermove', evt.pageX - offset.left, evt.pageY - offset.top);\n        });\n      }\n      if (this.options.resize) {\n        $(window).bind('resize', function(evt) {\n          if (_this.timeoutId != null) {\n            window.clearTimeout(_this.timeoutId);\n          }\n          return _this.timeoutId = window.setTimeout(_this.resizeHandler, 100);\n        });\n      }\n      this.el.css('-webkit-tap-highlight-color', 'rgba(0,0,0,0)');\n      if (this.postInit) {\n        this.postInit();\n      }\n    }\n\n    Grid.prototype.gridDefaults = {\n      dateFormat: null,\n      axes: true,\n      grid: true,\n      gridLineColor: '#aaa',\n      gridStrokeWidth: 0.5,\n      gridTextColor: '#888',\n      gridTextSize: 12,\n      gridTextFamily: 'sans-serif',\n      gridTextWeight: 'normal',\n      hideHover: false,\n      yLabelFormat: null,\n      xLabelAngle: 0,\n      numLines: 5,\n      padding: 25,\n      parseTime: true,\n      postUnits: '',\n      preUnits: '',\n      ymax: 'auto',\n      ymin: 'auto 0',\n      goals: [],\n      goalStrokeWidth: 1.0,\n      goalLineColors: ['#666633', '#999966', '#cc6666', '#663333'],\n      events: [],\n      eventStrokeWidth: 1.0,\n      eventLineColors: ['#005a04', '#ccffbb', '#3a5f0b', '#005502'],\n      rangeSelect: null,\n      rangeSelectColor: '#eef',\n      resize: false\n    };\n\n    Grid.prototype.setData = function(data, redraw) {\n      var e, idx, index, maxGoal, minGoal, ret, row, step, total, y, ykey, ymax, ymin, yval, _ref;\n      if (redraw == null) {\n        redraw = true;\n      }\n      this.options.data = data;\n      if ((data == null) || data.length === 0) {\n        this.data = [];\n        this.raphael.clear();\n        if (this.hover != null) {\n          this.hover.hide();\n        }\n        return;\n      }\n      ymax = this.cumulative ? 0 : null;\n      ymin = this.cumulative ? 0 : null;\n      if (this.options.goals.length > 0) {\n        minGoal = Math.min.apply(Math, this.options.goals);\n        maxGoal = Math.max.apply(Math, this.options.goals);\n        ymin = ymin != null ? Math.min(ymin, minGoal) : minGoal;\n        ymax = ymax != null ? Math.max(ymax, maxGoal) : maxGoal;\n      }\n      this.data = (function() {\n        var _i, _len, _results;\n        _results = [];\n        for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {\n          row = data[index];\n          ret = {\n            src: row\n          };\n          ret.label = row[this.options.xkey];\n          if (this.options.parseTime) {\n            ret.x = Morris.parseDate(ret.label);\n            if (this.options.dateFormat) {\n              ret.label = this.options.dateFormat(ret.x);\n            } else if (typeof ret.label === 'number') {\n              ret.label = new Date(ret.label).toString();\n            }\n          } else {\n            ret.x = index;\n            if (this.options.xLabelFormat) {\n              ret.label = this.options.xLabelFormat(ret);\n            }\n          }\n          total = 0;\n          ret.y = (function() {\n            var _j, _len1, _ref, _results1;\n            _ref = this.options.ykeys;\n            _results1 = [];\n            for (idx = _j = 0, _len1 = _ref.length; _j < _len1; idx = ++_j) {\n              ykey = _ref[idx];\n              yval = row[ykey];\n              if (typeof yval === 'string') {\n                yval = parseFloat(yval);\n              }\n              if ((yval != null) && typeof yval !== 'number') {\n                yval = null;\n              }\n              if (yval != null) {\n                if (this.cumulative) {\n                  total += yval;\n                } else {\n                  if (ymax != null) {\n                    ymax = Math.max(yval, ymax);\n                    ymin = Math.min(yval, ymin);\n                  } else {\n                    ymax = ymin = yval;\n                  }\n                }\n              }\n              if (this.cumulative && (total != null)) {\n                ymax = Math.max(total, ymax);\n                ymin = Math.min(total, ymin);\n              }\n              _results1.push(yval);\n            }\n            return _results1;\n          }).call(this);\n          _results.push(ret);\n        }\n        return _results;\n      }).call(this);\n      if (this.options.parseTime) {\n        this.data = this.data.sort(function(a, b) {\n          return (a.x > b.x) - (b.x > a.x);\n        });\n      }\n      this.xmin = this.data[0].x;\n      this.xmax = this.data[this.data.length - 1].x;\n      this.events = [];\n      if (this.options.events.length > 0) {\n        if (this.options.parseTime) {\n          this.events = (function() {\n            var _i, _len, _ref, _results;\n            _ref = this.options.events;\n            _results = [];\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n              e = _ref[_i];\n              _results.push(Morris.parseDate(e));\n            }\n            return _results;\n          }).call(this);\n        } else {\n          this.events = this.options.events;\n        }\n        this.xmax = Math.max(this.xmax, Math.max.apply(Math, this.events));\n        this.xmin = Math.min(this.xmin, Math.min.apply(Math, this.events));\n      }\n      if (this.xmin === this.xmax) {\n        this.xmin -= 1;\n        this.xmax += 1;\n      }\n      this.ymin = this.yboundary('min', ymin);\n      this.ymax = this.yboundary('max', ymax);\n      if (this.ymin === this.ymax) {\n        if (ymin) {\n          this.ymin -= 1;\n        }\n        this.ymax += 1;\n      }\n      if (((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'y') || this.options.grid === true) {\n        if (this.options.ymax === this.gridDefaults.ymax && this.options.ymin === this.gridDefaults.ymin) {\n          this.grid = this.autoGridLines(this.ymin, this.ymax, this.options.numLines);\n          this.ymin = Math.min(this.ymin, this.grid[0]);\n          this.ymax = Math.max(this.ymax, this.grid[this.grid.length - 1]);\n        } else {\n          step = (this.ymax - this.ymin) / (this.options.numLines - 1);\n          this.grid = (function() {\n            var _i, _ref1, _ref2, _results;\n            _results = [];\n            for (y = _i = _ref1 = this.ymin, _ref2 = this.ymax; step > 0 ? _i <= _ref2 : _i >= _ref2; y = _i += step) {\n              _results.push(y);\n            }\n            return _results;\n          }).call(this);\n        }\n      }\n      this.dirty = true;\n      if (redraw) {\n        return this.redraw();\n      }\n    };\n\n    Grid.prototype.yboundary = function(boundaryType, currentValue) {\n      var boundaryOption, suggestedValue;\n      boundaryOption = this.options[\"y\" + boundaryType];\n      if (typeof boundaryOption === 'string') {\n        if (boundaryOption.slice(0, 4) === 'auto') {\n          if (boundaryOption.length > 5) {\n            suggestedValue = parseInt(boundaryOption.slice(5), 10);\n            if (currentValue == null) {\n              return suggestedValue;\n            }\n            return Math[boundaryType](currentValue, suggestedValue);\n          } else {\n            if (currentValue != null) {\n              return currentValue;\n            } else {\n              return 0;\n            }\n          }\n        } else {\n          return parseInt(boundaryOption, 10);\n        }\n      } else {\n        return boundaryOption;\n      }\n    };\n\n    Grid.prototype.autoGridLines = function(ymin, ymax, nlines) {\n      var gmax, gmin, grid, smag, span, step, unit, y, ymag;\n      span = ymax - ymin;\n      ymag = Math.floor(Math.log(span) / Math.log(10));\n      unit = Math.pow(10, ymag);\n      gmin = Math.floor(ymin / unit) * unit;\n      gmax = Math.ceil(ymax / unit) * unit;\n      step = (gmax - gmin) / (nlines - 1);\n      if (unit === 1 && step > 1 && Math.ceil(step) !== step) {\n        step = Math.ceil(step);\n        gmax = gmin + step * (nlines - 1);\n      }\n      if (gmin < 0 && gmax > 0) {\n        gmin = Math.floor(ymin / step) * step;\n        gmax = Math.ceil(ymax / step) * step;\n      }\n      if (step < 1) {\n        smag = Math.floor(Math.log(step) / Math.log(10));\n        grid = (function() {\n          var _i, _results;\n          _results = [];\n          for (y = _i = gmin; step > 0 ? _i <= gmax : _i >= gmax; y = _i += step) {\n            _results.push(parseFloat(y.toFixed(1 - smag)));\n          }\n          return _results;\n        })();\n      } else {\n        grid = (function() {\n          var _i, _results;\n          _results = [];\n          for (y = _i = gmin; step > 0 ? _i <= gmax : _i >= gmax; y = _i += step) {\n            _results.push(y);\n          }\n          return _results;\n        })();\n      }\n      return grid;\n    };\n\n    Grid.prototype._calc = function() {\n      var bottomOffsets, gridLine, h, i, w, yLabelWidths, _ref, _ref1;\n      w = this.el.width();\n      h = this.el.height();\n      if (this.elementWidth !== w || this.elementHeight !== h || this.dirty) {\n        this.elementWidth = w;\n        this.elementHeight = h;\n        this.dirty = false;\n        this.left = this.options.padding;\n        this.right = this.elementWidth - this.options.padding;\n        this.top = this.options.padding;\n        this.bottom = this.elementHeight - this.options.padding;\n        if ((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'y') {\n          yLabelWidths = (function() {\n            var _i, _len, _ref1, _results;\n            _ref1 = this.grid;\n            _results = [];\n            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n              gridLine = _ref1[_i];\n              _results.push(this.measureText(this.yAxisFormat(gridLine)).width);\n            }\n            return _results;\n          }).call(this);\n          this.left += Math.max.apply(Math, yLabelWidths);\n        }\n        if ((_ref1 = this.options.axes) === true || _ref1 === 'both' || _ref1 === 'x') {\n          bottomOffsets = (function() {\n            var _i, _ref2, _results;\n            _results = [];\n            for (i = _i = 0, _ref2 = this.data.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {\n              _results.push(this.measureText(this.data[i].text, -this.options.xLabelAngle).height);\n            }\n            return _results;\n          }).call(this);\n          this.bottom -= Math.max.apply(Math, bottomOffsets);\n        }\n        this.width = Math.max(1, this.right - this.left);\n        this.height = Math.max(1, this.bottom - this.top);\n        this.dx = this.width / (this.xmax - this.xmin);\n        this.dy = this.height / (this.ymax - this.ymin);\n        if (this.calc) {\n          return this.calc();\n        }\n      }\n    };\n\n    Grid.prototype.transY = function(y) {\n      return this.bottom - (y - this.ymin) * this.dy;\n    };\n\n    Grid.prototype.transX = function(x) {\n      if (this.data.length === 1) {\n        return (this.left + this.right) / 2;\n      } else {\n        return this.left + (x - this.xmin) * this.dx;\n      }\n    };\n\n    Grid.prototype.redraw = function() {\n      this.raphael.clear();\n      this._calc();\n      this.drawGrid();\n      this.drawGoals();\n      this.drawEvents();\n      if (this.draw) {\n        return this.draw();\n      }\n    };\n\n    Grid.prototype.measureText = function(text, angle) {\n      var ret, tt;\n      if (angle == null) {\n        angle = 0;\n      }\n      tt = this.raphael.text(100, 100, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).rotate(angle);\n      ret = tt.getBBox();\n      tt.remove();\n      return ret;\n    };\n\n    Grid.prototype.yAxisFormat = function(label) {\n      return this.yLabelFormat(label);\n    };\n\n    Grid.prototype.yLabelFormat = function(label) {\n      if (typeof this.options.yLabelFormat === 'function') {\n        return this.options.yLabelFormat(label);\n      } else {\n        return \"\" + this.options.preUnits + (Morris.commas(label)) + this.options.postUnits;\n      }\n    };\n\n    Grid.prototype.drawGrid = function() {\n      var lineY, y, _i, _len, _ref, _ref1, _ref2, _results;\n      if (this.options.grid === false && ((_ref = this.options.axes) !== true && _ref !== 'both' && _ref !== 'y')) {\n        return;\n      }\n      _ref1 = this.grid;\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        lineY = _ref1[_i];\n        y = this.transY(lineY);\n        if ((_ref2 = this.options.axes) === true || _ref2 === 'both' || _ref2 === 'y') {\n          this.drawYAxisLabel(this.left - this.options.padding / 2, y, this.yAxisFormat(lineY));\n        }\n        if (this.options.grid) {\n          _results.push(this.drawGridLine(\"M\" + this.left + \",\" + y + \"H\" + (this.left + this.width)));\n        } else {\n          _results.push(void 0);\n        }\n      }\n      return _results;\n    };\n\n    Grid.prototype.drawGoals = function() {\n      var color, goal, i, _i, _len, _ref, _results;\n      _ref = this.options.goals;\n      _results = [];\n      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n        goal = _ref[i];\n        color = this.options.goalLineColors[i % this.options.goalLineColors.length];\n        _results.push(this.drawGoal(goal, color));\n      }\n      return _results;\n    };\n\n    Grid.prototype.drawEvents = function() {\n      var color, event, i, _i, _len, _ref, _results;\n      _ref = this.events;\n      _results = [];\n      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n        event = _ref[i];\n        color = this.options.eventLineColors[i % this.options.eventLineColors.length];\n        _results.push(this.drawEvent(event, color));\n      }\n      return _results;\n    };\n\n    Grid.prototype.drawGoal = function(goal, color) {\n      return this.raphael.path(\"M\" + this.left + \",\" + (this.transY(goal)) + \"H\" + this.right).attr('stroke', color).attr('stroke-width', this.options.goalStrokeWidth);\n    };\n\n    Grid.prototype.drawEvent = function(event, color) {\n      return this.raphael.path(\"M\" + (this.transX(event)) + \",\" + this.bottom + \"V\" + this.top).attr('stroke', color).attr('stroke-width', this.options.eventStrokeWidth);\n    };\n\n    Grid.prototype.drawYAxisLabel = function(xPos, yPos, text) {\n      return this.raphael.text(xPos, yPos, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).attr('fill', this.options.gridTextColor).attr('text-anchor', 'end');\n    };\n\n    Grid.prototype.drawGridLine = function(path) {\n      return this.raphael.path(path).attr('stroke', this.options.gridLineColor).attr('stroke-width', this.options.gridStrokeWidth);\n    };\n\n    Grid.prototype.startRange = function(x) {\n      this.hover.hide();\n      this.selectFrom = x;\n      return this.selectionRect.attr({\n        x: x,\n        width: 0\n      }).show();\n    };\n\n    Grid.prototype.endRange = function(x) {\n      var end, start;\n      if (this.selectFrom) {\n        start = Math.min(this.selectFrom, x);\n        end = Math.max(this.selectFrom, x);\n        this.options.rangeSelect.call(this.el, {\n          start: this.data[this.hitTest(start)].x,\n          end: this.data[this.hitTest(end)].x\n        });\n        return this.selectFrom = null;\n      }\n    };\n\n    Grid.prototype.resizeHandler = function() {\n      this.timeoutId = null;\n      this.raphael.setSize(this.el.width(), this.el.height());\n      return this.redraw();\n    };\n\n    return Grid;\n\n  })(Morris.EventEmitter);\n\n  Morris.parseDate = function(date) {\n    var isecs, m, msecs, n, o, offsetmins, p, q, r, ret, secs;\n    if (typeof date === 'number') {\n      return date;\n    }\n    m = date.match(/^(\\d+) Q(\\d)$/);\n    n = date.match(/^(\\d+)-(\\d+)$/);\n    o = date.match(/^(\\d+)-(\\d+)-(\\d+)$/);\n    p = date.match(/^(\\d+) W(\\d+)$/);\n    q = date.match(/^(\\d+)-(\\d+)-(\\d+)[ T](\\d+):(\\d+)(Z|([+-])(\\d\\d):?(\\d\\d))?$/);\n    r = date.match(/^(\\d+)-(\\d+)-(\\d+)[ T](\\d+):(\\d+):(\\d+(\\.\\d+)?)(Z|([+-])(\\d\\d):?(\\d\\d))?$/);\n    if (m) {\n      return new Date(parseInt(m[1], 10), parseInt(m[2], 10) * 3 - 1, 1).getTime();\n    } else if (n) {\n      return new Date(parseInt(n[1], 10), parseInt(n[2], 10) - 1, 1).getTime();\n    } else if (o) {\n      return new Date(parseInt(o[1], 10), parseInt(o[2], 10) - 1, parseInt(o[3], 10)).getTime();\n    } else if (p) {\n      ret = new Date(parseInt(p[1], 10), 0, 1);\n      if (ret.getDay() !== 4) {\n        ret.setMonth(0, 1 + ((4 - ret.getDay()) + 7) % 7);\n      }\n      return ret.getTime() + parseInt(p[2], 10) * 604800000;\n    } else if (q) {\n      if (!q[6]) {\n        return new Date(parseInt(q[1], 10), parseInt(q[2], 10) - 1, parseInt(q[3], 10), parseInt(q[4], 10), parseInt(q[5], 10)).getTime();\n      } else {\n        offsetmins = 0;\n        if (q[6] !== 'Z') {\n          offsetmins = parseInt(q[8], 10) * 60 + parseInt(q[9], 10);\n          if (q[7] === '+') {\n            offsetmins = 0 - offsetmins;\n          }\n        }\n        return Date.UTC(parseInt(q[1], 10), parseInt(q[2], 10) - 1, parseInt(q[3], 10), parseInt(q[4], 10), parseInt(q[5], 10) + offsetmins);\n      }\n    } else if (r) {\n      secs = parseFloat(r[6]);\n      isecs = Math.floor(secs);\n      msecs = Math.round((secs - isecs) * 1000);\n      if (!r[8]) {\n        return new Date(parseInt(r[1], 10), parseInt(r[2], 10) - 1, parseInt(r[3], 10), parseInt(r[4], 10), parseInt(r[5], 10), isecs, msecs).getTime();\n      } else {\n        offsetmins = 0;\n        if (r[8] !== 'Z') {\n          offsetmins = parseInt(r[10], 10) * 60 + parseInt(r[11], 10);\n          if (r[9] === '+') {\n            offsetmins = 0 - offsetmins;\n          }\n        }\n        return Date.UTC(parseInt(r[1], 10), parseInt(r[2], 10) - 1, parseInt(r[3], 10), parseInt(r[4], 10), parseInt(r[5], 10) + offsetmins, isecs, msecs);\n      }\n    } else {\n      return new Date(parseInt(date, 10), 0, 1).getTime();\n    }\n  };\n\n  Morris.Hover = (function() {\n    Hover.defaults = {\n      \"class\": 'morris-hover morris-default-style'\n    };\n\n    function Hover(options) {\n      if (options == null) {\n        options = {};\n      }\n      this.options = $.extend({}, Morris.Hover.defaults, options);\n      this.el = $(\"<div class='\" + this.options[\"class\"] + \"'></div>\");\n      this.el.hide();\n      this.options.parent.append(this.el);\n    }\n\n    Hover.prototype.update = function(html, x, y) {\n      if (!html) {\n        return this.hide();\n      } else {\n        this.html(html);\n        this.show();\n        return this.moveTo(x, y);\n      }\n    };\n\n    Hover.prototype.html = function(content) {\n      return this.el.html(content);\n    };\n\n    Hover.prototype.moveTo = function(x, y) {\n      var hoverHeight, hoverWidth, left, parentHeight, parentWidth, top;\n      parentWidth = this.options.parent.innerWidth();\n      parentHeight = this.options.parent.innerHeight();\n      hoverWidth = this.el.outerWidth();\n      hoverHeight = this.el.outerHeight();\n      left = Math.min(Math.max(0, x - hoverWidth / 2), parentWidth - hoverWidth);\n      if (y != null) {\n        top = y - hoverHeight - 10;\n        if (top < 0) {\n          top = y + 10;\n          if (top + hoverHeight > parentHeight) {\n            top = parentHeight / 2 - hoverHeight / 2;\n          }\n        }\n      } else {\n        top = parentHeight / 2 - hoverHeight / 2;\n      }\n      return this.el.css({\n        left: left + \"px\",\n        top: parseInt(top) + \"px\"\n      });\n    };\n\n    Hover.prototype.show = function() {\n      return this.el.show();\n    };\n\n    Hover.prototype.hide = function() {\n      return this.el.hide();\n    };\n\n    return Hover;\n\n  })();\n\n  Morris.Line = (function(_super) {\n    __extends(Line, _super);\n\n    function Line(options) {\n      this.hilight = __bind(this.hilight, this);\n      this.onHoverOut = __bind(this.onHoverOut, this);\n      this.onHoverMove = __bind(this.onHoverMove, this);\n      this.onGridClick = __bind(this.onGridClick, this);\n      if (!(this instanceof Morris.Line)) {\n        return new Morris.Line(options);\n      }\n      Line.__super__.constructor.call(this, options);\n    }\n\n    Line.prototype.init = function() {\n      if (this.options.hideHover !== 'always') {\n        this.hover = new Morris.Hover({\n          parent: this.el\n        });\n        this.on('hovermove', this.onHoverMove);\n        this.on('hoverout', this.onHoverOut);\n        return this.on('gridclick', this.onGridClick);\n      }\n    };\n\n    Line.prototype.defaults = {\n      lineWidth: 3,\n      pointSize: 4,\n      lineColors: ['#0b62a4', '#7A92A3', '#4da74d', '#afd8f8', '#edc240', '#cb4b4b', '#9440ed'],\n      pointStrokeWidths: [1],\n      pointStrokeColors: ['#ffffff'],\n      pointFillColors: [],\n      smooth: true,\n      xLabels: 'auto',\n      xLabelFormat: null,\n      xLabelMargin: 24,\n      hideHover: false\n    };\n\n    Line.prototype.calc = function() {\n      this.calcPoints();\n      return this.generatePaths();\n    };\n\n    Line.prototype.calcPoints = function() {\n      var row, y, _i, _len, _ref, _results;\n      _ref = this.data;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        row = _ref[_i];\n        row._x = this.transX(row.x);\n        row._y = (function() {\n          var _j, _len1, _ref1, _results1;\n          _ref1 = row.y;\n          _results1 = [];\n          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n            y = _ref1[_j];\n            if (y != null) {\n              _results1.push(this.transY(y));\n            } else {\n              _results1.push(y);\n            }\n          }\n          return _results1;\n        }).call(this);\n        _results.push(row._ymax = Math.min.apply(Math, [this.bottom].concat((function() {\n          var _j, _len1, _ref1, _results1;\n          _ref1 = row._y;\n          _results1 = [];\n          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n            y = _ref1[_j];\n            if (y != null) {\n              _results1.push(y);\n            }\n          }\n          return _results1;\n        })())));\n      }\n      return _results;\n    };\n\n    Line.prototype.hitTest = function(x) {\n      var index, r, _i, _len, _ref;\n      if (this.data.length === 0) {\n        return null;\n      }\n      _ref = this.data.slice(1);\n      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {\n        r = _ref[index];\n        if (x < (r._x + this.data[index]._x) / 2) {\n          break;\n        }\n      }\n      return index;\n    };\n\n    Line.prototype.onGridClick = function(x, y) {\n      var index;\n      index = this.hitTest(x);\n      return this.fire('click', index, this.data[index].src, x, y);\n    };\n\n    Line.prototype.onHoverMove = function(x, y) {\n      var index;\n      index = this.hitTest(x);\n      return this.displayHoverForRow(index);\n    };\n\n    Line.prototype.onHoverOut = function() {\n      if (this.options.hideHover !== false) {\n        return this.displayHoverForRow(null);\n      }\n    };\n\n    Line.prototype.displayHoverForRow = function(index) {\n      var _ref;\n      if (index != null) {\n        (_ref = this.hover).update.apply(_ref, this.hoverContentForRow(index));\n        return this.hilight(index);\n      } else {\n        this.hover.hide();\n        return this.hilight();\n      }\n    };\n\n    Line.prototype.hoverContentForRow = function(index) {\n      var content, j, row, y, _i, _len, _ref;\n      row = this.data[index];\n      content = \"<div class='morris-hover-row-label'>\" + row.label + \"</div>\";\n      _ref = row.y;\n      for (j = _i = 0, _len = _ref.length; _i < _len; j = ++_i) {\n        y = _ref[j];\n        content += \"<div class='morris-hover-point' style='color: \" + (this.colorFor(row, j, 'label')) + \"'>\\n  \" + this.options.labels[j] + \":\\n  \" + (this.yLabelFormat(y)) + \"\\n</div>\";\n      }\n      if (typeof this.options.hoverCallback === 'function') {\n        content = this.options.hoverCallback(index, this.options, content, row.src);\n      }\n      return [content, row._x, row._ymax];\n    };\n\n    Line.prototype.generatePaths = function() {\n      var coords, i, r, smooth;\n      return this.paths = (function() {\n        var _i, _ref, _ref1, _results;\n        _results = [];\n        for (i = _i = 0, _ref = this.options.ykeys.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n          smooth = typeof this.options.smooth === \"boolean\" ? this.options.smooth : (_ref1 = this.options.ykeys[i], __indexOf.call(this.options.smooth, _ref1) >= 0);\n          coords = (function() {\n            var _j, _len, _ref2, _results1;\n            _ref2 = this.data;\n            _results1 = [];\n            for (_j = 0, _len = _ref2.length; _j < _len; _j++) {\n              r = _ref2[_j];\n              if (r._y[i] !== void 0) {\n                _results1.push({\n                  x: r._x,\n                  y: r._y[i]\n                });\n              }\n            }\n            return _results1;\n          }).call(this);\n          if (coords.length > 1) {\n            _results.push(Morris.Line.createPath(coords, smooth, this.bottom));\n          } else {\n            _results.push(null);\n          }\n        }\n        return _results;\n      }).call(this);\n    };\n\n    Line.prototype.draw = function() {\n      var _ref;\n      if ((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'x') {\n        this.drawXAxis();\n      }\n      this.drawSeries();\n      if (this.options.hideHover === false) {\n        return this.displayHoverForRow(this.data.length - 1);\n      }\n    };\n\n    Line.prototype.drawXAxis = function() {\n      var drawLabel, l, labels, prevAngleMargin, prevLabelMargin, row, ypos, _i, _len, _results,\n        _this = this;\n      ypos = this.bottom + this.options.padding / 2;\n      prevLabelMargin = null;\n      prevAngleMargin = null;\n      drawLabel = function(labelText, xpos) {\n        var label, labelBox, margin, offset, textBox;\n        label = _this.drawXAxisLabel(_this.transX(xpos), ypos, labelText);\n        textBox = label.getBBox();\n        label.transform(\"r\" + (-_this.options.xLabelAngle));\n        labelBox = label.getBBox();\n        label.transform(\"t0,\" + (labelBox.height / 2) + \"...\");\n        if (_this.options.xLabelAngle !== 0) {\n          offset = -0.5 * textBox.width * Math.cos(_this.options.xLabelAngle * Math.PI / 180.0);\n          label.transform(\"t\" + offset + \",0...\");\n        }\n        labelBox = label.getBBox();\n        if (((prevLabelMargin == null) || prevLabelMargin >= labelBox.x + labelBox.width || (prevAngleMargin != null) && prevAngleMargin >= labelBox.x) && labelBox.x >= 0 && (labelBox.x + labelBox.width) < _this.el.width()) {\n          if (_this.options.xLabelAngle !== 0) {\n            margin = 1.25 * _this.options.gridTextSize / Math.sin(_this.options.xLabelAngle * Math.PI / 180.0);\n            prevAngleMargin = labelBox.x - margin;\n          }\n          return prevLabelMargin = labelBox.x - _this.options.xLabelMargin;\n        } else {\n          return label.remove();\n        }\n      };\n      if (this.options.parseTime) {\n        if (this.data.length === 1 && this.options.xLabels === 'auto') {\n          labels = [[this.data[0].label, this.data[0].x]];\n        } else {\n          labels = Morris.labelSeries(this.xmin, this.xmax, this.width, this.options.xLabels, this.options.xLabelFormat);\n        }\n      } else {\n        labels = (function() {\n          var _i, _len, _ref, _results;\n          _ref = this.data;\n          _results = [];\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            row = _ref[_i];\n            _results.push([row.label, row.x]);\n          }\n          return _results;\n        }).call(this);\n      }\n      labels.reverse();\n      _results = [];\n      for (_i = 0, _len = labels.length; _i < _len; _i++) {\n        l = labels[_i];\n        _results.push(drawLabel(l[0], l[1]));\n      }\n      return _results;\n    };\n\n    Line.prototype.drawSeries = function() {\n      var i, _i, _j, _ref, _ref1, _results;\n      this.seriesPoints = [];\n      for (i = _i = _ref = this.options.ykeys.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {\n        this._drawLineFor(i);\n      }\n      _results = [];\n      for (i = _j = _ref1 = this.options.ykeys.length - 1; _ref1 <= 0 ? _j <= 0 : _j >= 0; i = _ref1 <= 0 ? ++_j : --_j) {\n        _results.push(this._drawPointFor(i));\n      }\n      return _results;\n    };\n\n    Line.prototype._drawPointFor = function(index) {\n      var circle, row, _i, _len, _ref, _results;\n      this.seriesPoints[index] = [];\n      _ref = this.data;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        row = _ref[_i];\n        circle = null;\n        if (row._y[index] != null) {\n          circle = this.drawLinePoint(row._x, row._y[index], this.colorFor(row, index, 'point'), index);\n        }\n        _results.push(this.seriesPoints[index].push(circle));\n      }\n      return _results;\n    };\n\n    Line.prototype._drawLineFor = function(index) {\n      var path;\n      path = this.paths[index];\n      if (path !== null) {\n        return this.drawLinePath(path, this.colorFor(null, index, 'line'), index);\n      }\n    };\n\n    Line.createPath = function(coords, smooth, bottom) {\n      var coord, g, grads, i, ix, lg, path, prevCoord, x1, x2, y1, y2, _i, _len;\n      path = \"\";\n      if (smooth) {\n        grads = Morris.Line.gradients(coords);\n      }\n      prevCoord = {\n        y: null\n      };\n      for (i = _i = 0, _len = coords.length; _i < _len; i = ++_i) {\n        coord = coords[i];\n        if (coord.y != null) {\n          if (prevCoord.y != null) {\n            if (smooth) {\n              g = grads[i];\n              lg = grads[i - 1];\n              ix = (coord.x - prevCoord.x) / 4;\n              x1 = prevCoord.x + ix;\n              y1 = Math.min(bottom, prevCoord.y + ix * lg);\n              x2 = coord.x - ix;\n              y2 = Math.min(bottom, coord.y - ix * g);\n              path += \"C\" + x1 + \",\" + y1 + \",\" + x2 + \",\" + y2 + \",\" + coord.x + \",\" + coord.y;\n            } else {\n              path += \"L\" + coord.x + \",\" + coord.y;\n            }\n          } else {\n            if (!smooth || (grads[i] != null)) {\n              path += \"M\" + coord.x + \",\" + coord.y;\n            }\n          }\n        }\n        prevCoord = coord;\n      }\n      return path;\n    };\n\n    Line.gradients = function(coords) {\n      var coord, grad, i, nextCoord, prevCoord, _i, _len, _results;\n      grad = function(a, b) {\n        return (a.y - b.y) / (a.x - b.x);\n      };\n      _results = [];\n      for (i = _i = 0, _len = coords.length; _i < _len; i = ++_i) {\n        coord = coords[i];\n        if (coord.y != null) {\n          nextCoord = coords[i + 1] || {\n            y: null\n          };\n          prevCoord = coords[i - 1] || {\n            y: null\n          };\n          if ((prevCoord.y != null) && (nextCoord.y != null)) {\n            _results.push(grad(prevCoord, nextCoord));\n          } else if (prevCoord.y != null) {\n            _results.push(grad(prevCoord, coord));\n          } else if (nextCoord.y != null) {\n            _results.push(grad(coord, nextCoord));\n          } else {\n            _results.push(null);\n          }\n        } else {\n          _results.push(null);\n        }\n      }\n      return _results;\n    };\n\n    Line.prototype.hilight = function(index) {\n      var i, _i, _j, _ref, _ref1;\n      if (this.prevHilight !== null && this.prevHilight !== index) {\n        for (i = _i = 0, _ref = this.seriesPoints.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {\n          if (this.seriesPoints[i][this.prevHilight]) {\n            this.seriesPoints[i][this.prevHilight].animate(this.pointShrinkSeries(i));\n          }\n        }\n      }\n      if (index !== null && this.prevHilight !== index) {\n        for (i = _j = 0, _ref1 = this.seriesPoints.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n          if (this.seriesPoints[i][index]) {\n            this.seriesPoints[i][index].animate(this.pointGrowSeries(i));\n          }\n        }\n      }\n      return this.prevHilight = index;\n    };\n\n    Line.prototype.colorFor = function(row, sidx, type) {\n      if (typeof this.options.lineColors === 'function') {\n        return this.options.lineColors.call(this, row, sidx, type);\n      } else if (type === 'point') {\n        return this.options.pointFillColors[sidx % this.options.pointFillColors.length] || this.options.lineColors[sidx % this.options.lineColors.length];\n      } else {\n        return this.options.lineColors[sidx % this.options.lineColors.length];\n      }\n    };\n\n    Line.prototype.drawXAxisLabel = function(xPos, yPos, text) {\n      return this.raphael.text(xPos, yPos, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).attr('fill', this.options.gridTextColor);\n    };\n\n    Line.prototype.drawLinePath = function(path, lineColor, lineIndex) {\n      return this.raphael.path(path).attr('stroke', lineColor).attr('stroke-width', this.lineWidthForSeries(lineIndex));\n    };\n\n    Line.prototype.drawLinePoint = function(xPos, yPos, pointColor, lineIndex) {\n      return this.raphael.circle(xPos, yPos, this.pointSizeForSeries(lineIndex)).attr('fill', pointColor).attr('stroke-width', this.pointStrokeWidthForSeries(lineIndex)).attr('stroke', this.pointStrokeColorForSeries(lineIndex));\n    };\n\n    Line.prototype.pointStrokeWidthForSeries = function(index) {\n      return this.options.pointStrokeWidths[index % this.options.pointStrokeWidths.length];\n    };\n\n    Line.prototype.pointStrokeColorForSeries = function(index) {\n      return this.options.pointStrokeColors[index % this.options.pointStrokeColors.length];\n    };\n\n    Line.prototype.lineWidthForSeries = function(index) {\n      if (this.options.lineWidth instanceof Array) {\n        return this.options.lineWidth[index % this.options.lineWidth.length];\n      } else {\n        return this.options.lineWidth;\n      }\n    };\n\n    Line.prototype.pointSizeForSeries = function(index) {\n      if (this.options.pointSize instanceof Array) {\n        return this.options.pointSize[index % this.options.pointSize.length];\n      } else {\n        return this.options.pointSize;\n      }\n    };\n\n    Line.prototype.pointGrowSeries = function(index) {\n      return Raphael.animation({\n        r: this.pointSizeForSeries(index) + 3\n      }, 25, 'linear');\n    };\n\n    Line.prototype.pointShrinkSeries = function(index) {\n      return Raphael.animation({\n        r: this.pointSizeForSeries(index)\n      }, 25, 'linear');\n    };\n\n    return Line;\n\n  })(Morris.Grid);\n\n  Morris.labelSeries = function(dmin, dmax, pxwidth, specName, xLabelFormat) {\n    var d, d0, ddensity, name, ret, s, spec, t, _i, _len, _ref;\n    ddensity = 200 * (dmax - dmin) / pxwidth;\n    d0 = new Date(dmin);\n    spec = Morris.LABEL_SPECS[specName];\n    if (spec === void 0) {\n      _ref = Morris.AUTO_LABEL_ORDER;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        name = _ref[_i];\n        s = Morris.LABEL_SPECS[name];\n        if (ddensity >= s.span) {\n          spec = s;\n          break;\n        }\n      }\n    }\n    if (spec === void 0) {\n      spec = Morris.LABEL_SPECS[\"second\"];\n    }\n    if (xLabelFormat) {\n      spec = $.extend({}, spec, {\n        fmt: xLabelFormat\n      });\n    }\n    d = spec.start(d0);\n    ret = [];\n    while ((t = d.getTime()) <= dmax) {\n      if (t >= dmin) {\n        ret.push([spec.fmt(d), t]);\n      }\n      spec.incr(d);\n    }\n    return ret;\n  };\n\n  minutesSpecHelper = function(interval) {\n    return {\n      span: interval * 60 * 1000,\n      start: function(d) {\n        return new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours());\n      },\n      fmt: function(d) {\n        return \"\" + (Morris.pad2(d.getHours())) + \":\" + (Morris.pad2(d.getMinutes()));\n      },\n      incr: function(d) {\n        return d.setUTCMinutes(d.getUTCMinutes() + interval);\n      }\n    };\n  };\n\n  secondsSpecHelper = function(interval) {\n    return {\n      span: interval * 1000,\n      start: function(d) {\n        return new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes());\n      },\n      fmt: function(d) {\n        return \"\" + (Morris.pad2(d.getHours())) + \":\" + (Morris.pad2(d.getMinutes())) + \":\" + (Morris.pad2(d.getSeconds()));\n      },\n      incr: function(d) {\n        return d.setUTCSeconds(d.getUTCSeconds() + interval);\n      }\n    };\n  };\n\n  Morris.LABEL_SPECS = {\n    \"decade\": {\n      span: 172800000000,\n      start: function(d) {\n        return new Date(d.getFullYear() - d.getFullYear() % 10, 0, 1);\n      },\n      fmt: function(d) {\n        return \"\" + (d.getFullYear());\n      },\n      incr: function(d) {\n        return d.setFullYear(d.getFullYear() + 10);\n      }\n    },\n    \"year\": {\n      span: 17280000000,\n      start: function(d) {\n        return new Date(d.getFullYear(), 0, 1);\n      },\n      fmt: function(d) {\n        return \"\" + (d.getFullYear());\n      },\n      incr: function(d) {\n        return d.setFullYear(d.getFullYear() + 1);\n      }\n    },\n    \"month\": {\n      span: 2419200000,\n      start: function(d) {\n        return new Date(d.getFullYear(), d.getMonth(), 1);\n      },\n      fmt: function(d) {\n        return \"\" + (d.getFullYear()) + \"-\" + (Morris.pad2(d.getMonth() + 1));\n      },\n      incr: function(d) {\n        return d.setMonth(d.getMonth() + 1);\n      }\n    },\n    \"week\": {\n      span: 604800000,\n      start: function(d) {\n        return new Date(d.getFullYear(), d.getMonth(), d.getDate());\n      },\n      fmt: function(d) {\n        return \"\" + (d.getFullYear()) + \"-\" + (Morris.pad2(d.getMonth() + 1)) + \"-\" + (Morris.pad2(d.getDate()));\n      },\n      incr: function(d) {\n        return d.setDate(d.getDate() + 7);\n      }\n    },\n    \"day\": {\n      span: 86400000,\n      start: function(d) {\n        return new Date(d.getFullYear(), d.getMonth(), d.getDate());\n      },\n      fmt: function(d) {\n        return \"\" + (d.getFullYear()) + \"-\" + (Morris.pad2(d.getMonth() + 1)) + \"-\" + (Morris.pad2(d.getDate()));\n      },\n      incr: function(d) {\n        return d.setDate(d.getDate() + 1);\n      }\n    },\n    \"hour\": minutesSpecHelper(60),\n    \"30min\": minutesSpecHelper(30),\n    \"15min\": minutesSpecHelper(15),\n    \"10min\": minutesSpecHelper(10),\n    \"5min\": minutesSpecHelper(5),\n    \"minute\": minutesSpecHelper(1),\n    \"30sec\": secondsSpecHelper(30),\n    \"15sec\": secondsSpecHelper(15),\n    \"10sec\": secondsSpecHelper(10),\n    \"5sec\": secondsSpecHelper(5),\n    \"second\": secondsSpecHelper(1)\n  };\n\n  Morris.AUTO_LABEL_ORDER = [\"decade\", \"year\", \"month\", \"week\", \"day\", \"hour\", \"30min\", \"15min\", \"10min\", \"5min\", \"minute\", \"30sec\", \"15sec\", \"10sec\", \"5sec\", \"second\"];\n\n  Morris.Area = (function(_super) {\n    var areaDefaults;\n\n    __extends(Area, _super);\n\n    areaDefaults = {\n      fillOpacity: 'auto',\n      behaveLikeLine: false\n    };\n\n    function Area(options) {\n      var areaOptions;\n      if (!(this instanceof Morris.Area)) {\n        return new Morris.Area(options);\n      }\n      areaOptions = $.extend({}, areaDefaults, options);\n      this.cumulative = !areaOptions.behaveLikeLine;\n      if (areaOptions.fillOpacity === 'auto') {\n        areaOptions.fillOpacity = areaOptions.behaveLikeLine ? .8 : 1;\n      }\n      Area.__super__.constructor.call(this, areaOptions);\n    }\n\n    Area.prototype.calcPoints = function() {\n      var row, total, y, _i, _len, _ref, _results;\n      _ref = this.data;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        row = _ref[_i];\n        row._x = this.transX(row.x);\n        total = 0;\n        row._y = (function() {\n          var _j, _len1, _ref1, _results1;\n          _ref1 = row.y;\n          _results1 = [];\n          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n            y = _ref1[_j];\n            if (this.options.behaveLikeLine) {\n              _results1.push(this.transY(y));\n            } else {\n              total += y || 0;\n              _results1.push(this.transY(total));\n            }\n          }\n          return _results1;\n        }).call(this);\n        _results.push(row._ymax = Math.max.apply(Math, row._y));\n      }\n      return _results;\n    };\n\n    Area.prototype.drawSeries = function() {\n      var i, range, _i, _j, _k, _len, _ref, _ref1, _results, _results1, _results2;\n      this.seriesPoints = [];\n      if (this.options.behaveLikeLine) {\n        range = (function() {\n          _results = [];\n          for (var _i = 0, _ref = this.options.ykeys.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }\n          return _results;\n        }).apply(this);\n      } else {\n        range = (function() {\n          _results1 = [];\n          for (var _j = _ref1 = this.options.ykeys.length - 1; _ref1 <= 0 ? _j <= 0 : _j >= 0; _ref1 <= 0 ? _j++ : _j--){ _results1.push(_j); }\n          return _results1;\n        }).apply(this);\n      }\n      _results2 = [];\n      for (_k = 0, _len = range.length; _k < _len; _k++) {\n        i = range[_k];\n        this._drawFillFor(i);\n        this._drawLineFor(i);\n        _results2.push(this._drawPointFor(i));\n      }\n      return _results2;\n    };\n\n    Area.prototype._drawFillFor = function(index) {\n      var path;\n      path = this.paths[index];\n      if (path !== null) {\n        path = path + (\"L\" + (this.transX(this.xmax)) + \",\" + this.bottom + \"L\" + (this.transX(this.xmin)) + \",\" + this.bottom + \"Z\");\n        return this.drawFilledPath(path, this.fillForSeries(index));\n      }\n    };\n\n    Area.prototype.fillForSeries = function(i) {\n      var color;\n      color = Raphael.rgb2hsl(this.colorFor(this.data[i], i, 'line'));\n      return Raphael.hsl(color.h, this.options.behaveLikeLine ? color.s * 0.9 : color.s * 0.75, Math.min(0.98, this.options.behaveLikeLine ? color.l * 1.2 : color.l * 1.25));\n    };\n\n    Area.prototype.drawFilledPath = function(path, fill) {\n      return this.raphael.path(path).attr('fill', fill).attr('fill-opacity', this.options.fillOpacity).attr('stroke', 'none');\n    };\n\n    return Area;\n\n  })(Morris.Line);\n\n  Morris.Bar = (function(_super) {\n    __extends(Bar, _super);\n\n    function Bar(options) {\n      this.onHoverOut = __bind(this.onHoverOut, this);\n      this.onHoverMove = __bind(this.onHoverMove, this);\n      this.onGridClick = __bind(this.onGridClick, this);\n      if (!(this instanceof Morris.Bar)) {\n        return new Morris.Bar(options);\n      }\n      Bar.__super__.constructor.call(this, $.extend({}, options, {\n        parseTime: false\n      }));\n    }\n\n    Bar.prototype.init = function() {\n      this.cumulative = this.options.stacked;\n      if (this.options.hideHover !== 'always') {\n        this.hover = new Morris.Hover({\n          parent: this.el\n        });\n        this.on('hovermove', this.onHoverMove);\n        this.on('hoverout', this.onHoverOut);\n        return this.on('gridclick', this.onGridClick);\n      }\n    };\n\n    Bar.prototype.defaults = {\n      barSizeRatio: 0.75,\n      barGap: 3,\n      barColors: ['#0b62a4', '#7a92a3', '#4da74d', '#afd8f8', '#edc240', '#cb4b4b', '#9440ed'],\n      barOpacity: 1.0,\n      barRadius: [0, 0, 0, 0],\n      xLabelMargin: 50\n    };\n\n    Bar.prototype.calc = function() {\n      var _ref;\n      this.calcBars();\n      if (this.options.hideHover === false) {\n        return (_ref = this.hover).update.apply(_ref, this.hoverContentForRow(this.data.length - 1));\n      }\n    };\n\n    Bar.prototype.calcBars = function() {\n      var idx, row, y, _i, _len, _ref, _results;\n      _ref = this.data;\n      _results = [];\n      for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {\n        row = _ref[idx];\n        row._x = this.left + this.width * (idx + 0.5) / this.data.length;\n        _results.push(row._y = (function() {\n          var _j, _len1, _ref1, _results1;\n          _ref1 = row.y;\n          _results1 = [];\n          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n            y = _ref1[_j];\n            if (y != null) {\n              _results1.push(this.transY(y));\n            } else {\n              _results1.push(null);\n            }\n          }\n          return _results1;\n        }).call(this));\n      }\n      return _results;\n    };\n\n    Bar.prototype.draw = function() {\n      var _ref;\n      if ((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'x') {\n        this.drawXAxis();\n      }\n      return this.drawSeries();\n    };\n\n    Bar.prototype.drawXAxis = function() {\n      var i, label, labelBox, margin, offset, prevAngleMargin, prevLabelMargin, row, textBox, ypos, _i, _ref, _results;\n      ypos = this.bottom + (this.options.xAxisLabelTopPadding || this.options.padding / 2);\n      prevLabelMargin = null;\n      prevAngleMargin = null;\n      _results = [];\n      for (i = _i = 0, _ref = this.data.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n        row = this.data[this.data.length - 1 - i];\n        label = this.drawXAxisLabel(row._x, ypos, row.label);\n        textBox = label.getBBox();\n        label.transform(\"r\" + (-this.options.xLabelAngle));\n        labelBox = label.getBBox();\n        label.transform(\"t0,\" + (labelBox.height / 2) + \"...\");\n        if (this.options.xLabelAngle !== 0) {\n          offset = -0.5 * textBox.width * Math.cos(this.options.xLabelAngle * Math.PI / 180.0);\n          label.transform(\"t\" + offset + \",0...\");\n        }\n        if (((prevLabelMargin == null) || prevLabelMargin >= labelBox.x + labelBox.width || (prevAngleMargin != null) && prevAngleMargin >= labelBox.x) && labelBox.x >= 0 && (labelBox.x + labelBox.width) < this.el.width()) {\n          if (this.options.xLabelAngle !== 0) {\n            margin = 1.25 * this.options.gridTextSize / Math.sin(this.options.xLabelAngle * Math.PI / 180.0);\n            prevAngleMargin = labelBox.x - margin;\n          }\n          _results.push(prevLabelMargin = labelBox.x - this.options.xLabelMargin);\n        } else {\n          _results.push(label.remove());\n        }\n      }\n      return _results;\n    };\n\n    Bar.prototype.drawSeries = function() {\n      var barWidth, bottom, groupWidth, idx, lastTop, left, leftPadding, numBars, row, sidx, size, spaceLeft, top, ypos, zeroPos;\n      groupWidth = this.width / this.options.data.length;\n      numBars = this.options.stacked ? 1 : this.options.ykeys.length;\n      barWidth = (groupWidth * this.options.barSizeRatio - this.options.barGap * (numBars - 1)) / numBars;\n      if (this.options.barSize) {\n        barWidth = Math.min(barWidth, this.options.barSize);\n      }\n      spaceLeft = groupWidth - barWidth * numBars - this.options.barGap * (numBars - 1);\n      leftPadding = spaceLeft / 2;\n      zeroPos = this.ymin <= 0 && this.ymax >= 0 ? this.transY(0) : null;\n      return this.bars = (function() {\n        var _i, _len, _ref, _results;\n        _ref = this.data;\n        _results = [];\n        for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {\n          row = _ref[idx];\n          lastTop = 0;\n          _results.push((function() {\n            var _j, _len1, _ref1, _results1;\n            _ref1 = row._y;\n            _results1 = [];\n            for (sidx = _j = 0, _len1 = _ref1.length; _j < _len1; sidx = ++_j) {\n              ypos = _ref1[sidx];\n              if (ypos !== null) {\n                if (zeroPos) {\n                  top = Math.min(ypos, zeroPos);\n                  bottom = Math.max(ypos, zeroPos);\n                } else {\n                  top = ypos;\n                  bottom = this.bottom;\n                }\n                left = this.left + idx * groupWidth + leftPadding;\n                if (!this.options.stacked) {\n                  left += sidx * (barWidth + this.options.barGap);\n                }\n                size = bottom - top;\n                if (this.options.verticalGridCondition && this.options.verticalGridCondition(row.x)) {\n                  this.drawBar(this.left + idx * groupWidth, this.top, groupWidth, Math.abs(this.top - this.bottom), this.options.verticalGridColor, this.options.verticalGridOpacity, this.options.barRadius);\n                }\n                if (this.options.stacked) {\n                  top -= lastTop;\n                }\n                this.drawBar(left, top, barWidth, size, this.colorFor(row, sidx, 'bar'), this.options.barOpacity, this.options.barRadius);\n                _results1.push(lastTop += size);\n              } else {\n                _results1.push(null);\n              }\n            }\n            return _results1;\n          }).call(this));\n        }\n        return _results;\n      }).call(this);\n    };\n\n    Bar.prototype.colorFor = function(row, sidx, type) {\n      var r, s;\n      if (typeof this.options.barColors === 'function') {\n        r = {\n          x: row.x,\n          y: row.y[sidx],\n          label: row.label\n        };\n        s = {\n          index: sidx,\n          key: this.options.ykeys[sidx],\n          label: this.options.labels[sidx]\n        };\n        return this.options.barColors.call(this, r, s, type);\n      } else {\n        return this.options.barColors[sidx % this.options.barColors.length];\n      }\n    };\n\n    Bar.prototype.hitTest = function(x) {\n      if (this.data.length === 0) {\n        return null;\n      }\n      x = Math.max(Math.min(x, this.right), this.left);\n      return Math.min(this.data.length - 1, Math.floor((x - this.left) / (this.width / this.data.length)));\n    };\n\n    Bar.prototype.onGridClick = function(x, y) {\n      var index;\n      index = this.hitTest(x);\n      return this.fire('click', index, this.data[index].src, x, y);\n    };\n\n    Bar.prototype.onHoverMove = function(x, y) {\n      var index, _ref;\n      index = this.hitTest(x);\n      return (_ref = this.hover).update.apply(_ref, this.hoverContentForRow(index));\n    };\n\n    Bar.prototype.onHoverOut = function() {\n      if (this.options.hideHover !== false) {\n        return this.hover.hide();\n      }\n    };\n\n    Bar.prototype.hoverContentForRow = function(index) {\n      var content, j, row, x, y, _i, _len, _ref;\n      row = this.data[index];\n      content = \"<div class='morris-hover-row-label'>\" + row.label + \"</div>\";\n      _ref = row.y;\n      for (j = _i = 0, _len = _ref.length; _i < _len; j = ++_i) {\n        y = _ref[j];\n        content += \"<div class='morris-hover-point' style='color: \" + (this.colorFor(row, j, 'label')) + \"'>\\n  \" + this.options.labels[j] + \":\\n  \" + (this.yLabelFormat(y)) + \"\\n</div>\";\n      }\n      if (typeof this.options.hoverCallback === 'function') {\n        content = this.options.hoverCallback(index, this.options, content, row.src);\n      }\n      x = this.left + (index + 0.5) * this.width / this.data.length;\n      return [content, x];\n    };\n\n    Bar.prototype.drawXAxisLabel = function(xPos, yPos, text) {\n      var label;\n      return label = this.raphael.text(xPos, yPos, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).attr('fill', this.options.gridTextColor);\n    };\n\n    Bar.prototype.drawBar = function(xPos, yPos, width, height, barColor, opacity, radiusArray) {\n      var maxRadius, path;\n      maxRadius = Math.max.apply(Math, radiusArray);\n      if (maxRadius === 0 || maxRadius > height) {\n        path = this.raphael.rect(xPos, yPos, width, height);\n      } else {\n        path = this.raphael.path(this.roundedRect(xPos, yPos, width, height, radiusArray));\n      }\n      return path.attr('fill', barColor).attr('fill-opacity', opacity).attr('stroke', 'none');\n    };\n\n    Bar.prototype.roundedRect = function(x, y, w, h, r) {\n      if (r == null) {\n        r = [0, 0, 0, 0];\n      }\n      return [\"M\", x, r[0] + y, \"Q\", x, y, x + r[0], y, \"L\", x + w - r[1], y, \"Q\", x + w, y, x + w, y + r[1], \"L\", x + w, y + h - r[2], \"Q\", x + w, y + h, x + w - r[2], y + h, \"L\", x + r[3], y + h, \"Q\", x, y + h, x, y + h - r[3], \"Z\"];\n    };\n\n    return Bar;\n\n  })(Morris.Grid);\n\n  Morris.Donut = (function(_super) {\n    __extends(Donut, _super);\n\n    Donut.prototype.defaults = {\n      colors: ['#0B62A4', '#3980B5', '#679DC6', '#95BBD7', '#B0CCE1', '#095791', '#095085', '#083E67', '#052C48', '#042135'],\n      backgroundColor: '#FFFFFF',\n      labelColor: '#000000',\n      formatter: Morris.commas,\n      resize: false\n    };\n\n    function Donut(options) {\n      this.resizeHandler = __bind(this.resizeHandler, this);\n      this.select = __bind(this.select, this);\n      this.click = __bind(this.click, this);\n      var _this = this;\n      if (!(this instanceof Morris.Donut)) {\n        return new Morris.Donut(options);\n      }\n      this.options = $.extend({}, this.defaults, options);\n      if (typeof options.element === 'string') {\n        this.el = $(document.getElementById(options.element));\n      } else {\n        this.el = $(options.element);\n      }\n      if (this.el === null || this.el.length === 0) {\n        throw new Error(\"Graph placeholder not found.\");\n      }\n      if (options.data === void 0 || options.data.length === 0) {\n        return;\n      }\n      this.raphael = new Raphael(this.el[0]);\n      if (this.options.resize) {\n        $(window).bind('resize', function(evt) {\n          if (_this.timeoutId != null) {\n            window.clearTimeout(_this.timeoutId);\n          }\n          return _this.timeoutId = window.setTimeout(_this.resizeHandler, 100);\n        });\n      }\n      this.setData(options.data);\n    }\n\n    Donut.prototype.redraw = function() {\n      var C, cx, cy, i, idx, last, max_value, min, next, seg, total, value, w, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;\n      this.raphael.clear();\n      cx = this.el.width() / 2;\n      cy = this.el.height() / 2;\n      w = (Math.min(cx, cy) - 10) / 3;\n      total = 0;\n      _ref = this.values;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        value = _ref[_i];\n        total += value;\n      }\n      min = 5 / (2 * w);\n      C = 1.9999 * Math.PI - min * this.data.length;\n      last = 0;\n      idx = 0;\n      this.segments = [];\n      _ref1 = this.values;\n      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {\n        value = _ref1[i];\n        next = last + min + C * (value / total);\n        seg = new Morris.DonutSegment(cx, cy, w * 2, w, last, next, this.data[i].color || this.options.colors[idx % this.options.colors.length], this.options.backgroundColor, idx, this.raphael);\n        seg.render();\n        this.segments.push(seg);\n        seg.on('hover', this.select);\n        seg.on('click', this.click);\n        last = next;\n        idx += 1;\n      }\n      this.text1 = this.drawEmptyDonutLabel(cx, cy - 10, this.options.labelColor, 15, 800);\n      this.text2 = this.drawEmptyDonutLabel(cx, cy + 10, this.options.labelColor, 14);\n      max_value = Math.max.apply(Math, this.values);\n      idx = 0;\n      _ref2 = this.values;\n      _results = [];\n      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {\n        value = _ref2[_k];\n        if (value === max_value) {\n          this.select(idx);\n          break;\n        }\n        _results.push(idx += 1);\n      }\n      return _results;\n    };\n\n    Donut.prototype.setData = function(data) {\n      var row;\n      this.data = data;\n      this.values = (function() {\n        var _i, _len, _ref, _results;\n        _ref = this.data;\n        _results = [];\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          row = _ref[_i];\n          _results.push(parseFloat(row.value));\n        }\n        return _results;\n      }).call(this);\n      return this.redraw();\n    };\n\n    Donut.prototype.click = function(idx) {\n      return this.fire('click', idx, this.data[idx]);\n    };\n\n    Donut.prototype.select = function(idx) {\n      var row, s, segment, _i, _len, _ref;\n      _ref = this.segments;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        s = _ref[_i];\n        s.deselect();\n      }\n      segment = this.segments[idx];\n      segment.select();\n      row = this.data[idx];\n      return this.setLabels(row.label, this.options.formatter(row.value, row));\n    };\n\n    Donut.prototype.setLabels = function(label1, label2) {\n      var inner, maxHeightBottom, maxHeightTop, maxWidth, text1bbox, text1scale, text2bbox, text2scale;\n      inner = (Math.min(this.el.width() / 2, this.el.height() / 2) - 10) * 2 / 3;\n      maxWidth = 1.8 * inner;\n      maxHeightTop = inner / 2;\n      maxHeightBottom = inner / 3;\n      this.text1.attr({\n        text: label1,\n        transform: ''\n      });\n      text1bbox = this.text1.getBBox();\n      text1scale = Math.min(maxWidth / text1bbox.width, maxHeightTop / text1bbox.height);\n      this.text1.attr({\n        transform: \"S\" + text1scale + \",\" + text1scale + \",\" + (text1bbox.x + text1bbox.width / 2) + \",\" + (text1bbox.y + text1bbox.height)\n      });\n      this.text2.attr({\n        text: label2,\n        transform: ''\n      });\n      text2bbox = this.text2.getBBox();\n      text2scale = Math.min(maxWidth / text2bbox.width, maxHeightBottom / text2bbox.height);\n      return this.text2.attr({\n        transform: \"S\" + text2scale + \",\" + text2scale + \",\" + (text2bbox.x + text2bbox.width / 2) + \",\" + text2bbox.y\n      });\n    };\n\n    Donut.prototype.drawEmptyDonutLabel = function(xPos, yPos, color, fontSize, fontWeight) {\n      var text;\n      text = this.raphael.text(xPos, yPos, '').attr('font-size', fontSize).attr('fill', color);\n      if (fontWeight != null) {\n        text.attr('font-weight', fontWeight);\n      }\n      return text;\n    };\n\n    Donut.prototype.resizeHandler = function() {\n      this.timeoutId = null;\n      this.raphael.setSize(this.el.width(), this.el.height());\n      return this.redraw();\n    };\n\n    return Donut;\n\n  })(Morris.EventEmitter);\n\n  Morris.DonutSegment = (function(_super) {\n    __extends(DonutSegment, _super);\n\n    function DonutSegment(cx, cy, inner, outer, p0, p1, color, backgroundColor, index, raphael) {\n      this.cx = cx;\n      this.cy = cy;\n      this.inner = inner;\n      this.outer = outer;\n      this.color = color;\n      this.backgroundColor = backgroundColor;\n      this.index = index;\n      this.raphael = raphael;\n      this.deselect = __bind(this.deselect, this);\n      this.select = __bind(this.select, this);\n      this.sin_p0 = Math.sin(p0);\n      this.cos_p0 = Math.cos(p0);\n      this.sin_p1 = Math.sin(p1);\n      this.cos_p1 = Math.cos(p1);\n      this.is_long = (p1 - p0) > Math.PI ? 1 : 0;\n      this.path = this.calcSegment(this.inner + 3, this.inner + this.outer - 5);\n      this.selectedPath = this.calcSegment(this.inner + 3, this.inner + this.outer);\n      this.hilight = this.calcArc(this.inner);\n    }\n\n    DonutSegment.prototype.calcArcPoints = function(r) {\n      return [this.cx + r * this.sin_p0, this.cy + r * this.cos_p0, this.cx + r * this.sin_p1, this.cy + r * this.cos_p1];\n    };\n\n    DonutSegment.prototype.calcSegment = function(r1, r2) {\n      var ix0, ix1, iy0, iy1, ox0, ox1, oy0, oy1, _ref, _ref1;\n      _ref = this.calcArcPoints(r1), ix0 = _ref[0], iy0 = _ref[1], ix1 = _ref[2], iy1 = _ref[3];\n      _ref1 = this.calcArcPoints(r2), ox0 = _ref1[0], oy0 = _ref1[1], ox1 = _ref1[2], oy1 = _ref1[3];\n      return (\"M\" + ix0 + \",\" + iy0) + (\"A\" + r1 + \",\" + r1 + \",0,\" + this.is_long + \",0,\" + ix1 + \",\" + iy1) + (\"L\" + ox1 + \",\" + oy1) + (\"A\" + r2 + \",\" + r2 + \",0,\" + this.is_long + \",1,\" + ox0 + \",\" + oy0) + \"Z\";\n    };\n\n    DonutSegment.prototype.calcArc = function(r) {\n      var ix0, ix1, iy0, iy1, _ref;\n      _ref = this.calcArcPoints(r), ix0 = _ref[0], iy0 = _ref[1], ix1 = _ref[2], iy1 = _ref[3];\n      return (\"M\" + ix0 + \",\" + iy0) + (\"A\" + r + \",\" + r + \",0,\" + this.is_long + \",0,\" + ix1 + \",\" + iy1);\n    };\n\n    DonutSegment.prototype.render = function() {\n      var _this = this;\n      this.arc = this.drawDonutArc(this.hilight, this.color);\n      return this.seg = this.drawDonutSegment(this.path, this.color, this.backgroundColor, function() {\n        return _this.fire('hover', _this.index);\n      }, function() {\n        return _this.fire('click', _this.index);\n      });\n    };\n\n    DonutSegment.prototype.drawDonutArc = function(path, color) {\n      return this.raphael.path(path).attr({\n        stroke: color,\n        'stroke-width': 2,\n        opacity: 0\n      });\n    };\n\n    DonutSegment.prototype.drawDonutSegment = function(path, fillColor, strokeColor, hoverFunction, clickFunction) {\n      return this.raphael.path(path).attr({\n        fill: fillColor,\n        stroke: strokeColor,\n        'stroke-width': 3\n      }).hover(hoverFunction).click(clickFunction);\n    };\n\n    DonutSegment.prototype.select = function() {\n      if (!this.selected) {\n        this.seg.animate({\n          path: this.selectedPath\n        }, 150, '<>');\n        this.arc.animate({\n          opacity: 1\n        }, 150, '<>');\n        return this.selected = true;\n      }\n    };\n\n    DonutSegment.prototype.deselect = function() {\n      if (this.selected) {\n        this.seg.animate({\n          path: this.path\n        }, 150, '<>');\n        this.arc.animate({\n          opacity: 0\n        }, 150, '<>');\n        return this.selected = false;\n      }\n    };\n\n    return DonutSegment;\n\n  })(Morris.EventEmitter);\n\n}).call(this);\n","require('morris.js/morris');\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbW9ycmlzLmpzL21vcnJpcy5qcyIsImJ1aWxkL3ZlbmRvcnMvbW9ycmlzL21vcnJpcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3AyREEsUUFBUSxrQkFBUiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKiBAbGljZW5zZVxubW9ycmlzLmpzIHYwLjUuMFxuQ29weXJpZ2h0IDIwMTQgT2xseSBTbWl0aCBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEJTRC0yLUNsYXVzZSBMaWNlbnNlLlxuKi9cblxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciAkLCBNb3JyaXMsIG1pbnV0ZXNTcGVjSGVscGVyLCBzZWNvbmRzU3BlY0hlbHBlcixcbiAgICBfX3NsaWNlID0gW10uc2xpY2UsXG4gICAgX19iaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfSxcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBfX2luZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpOyB9IHJldHVybiAtMTsgfTtcblxuICBNb3JyaXMgPSB3aW5kb3cuTW9ycmlzID0ge307XG5cbiAgJCA9IGpRdWVyeTtcblxuICBNb3JyaXMuRXZlbnRFbWl0dGVyID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHt9XG5cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24obmFtZSwgaGFuZGxlcikge1xuICAgICAgaWYgKHRoaXMuaGFuZGxlcnMgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYW5kbGVyc1tuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnNbbmFtZV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGFuZGxlcnNbbmFtZV0ucHVzaChoYW5kbGVyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmZpcmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzLCBoYW5kbGVyLCBuYW1lLCBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICBuYW1lID0gYXJndW1lbnRzWzBdLCBhcmdzID0gMiA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkgOiBbXTtcbiAgICAgIGlmICgodGhpcy5oYW5kbGVycyAhPSBudWxsKSAmJiAodGhpcy5oYW5kbGVyc1tuYW1lXSAhPSBudWxsKSkge1xuICAgICAgICBfcmVmID0gdGhpcy5oYW5kbGVyc1tuYW1lXTtcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgaGFuZGxlciA9IF9yZWZbX2ldO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goaGFuZGxlci5hcHBseShudWxsLCBhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xuXG4gIH0pKCk7XG5cbiAgTW9ycmlzLmNvbW1hcyA9IGZ1bmN0aW9uKG51bSkge1xuICAgIHZhciBhYnNudW0sIGludG51bSwgcmV0LCBzdHJhYnNudW07XG4gICAgaWYgKG51bSAhPSBudWxsKSB7XG4gICAgICByZXQgPSBudW0gPCAwID8gXCItXCIgOiBcIlwiO1xuICAgICAgYWJzbnVtID0gTWF0aC5hYnMobnVtKTtcbiAgICAgIGludG51bSA9IE1hdGguZmxvb3IoYWJzbnVtKS50b0ZpeGVkKDApO1xuICAgICAgcmV0ICs9IGludG51bS5yZXBsYWNlKC8oPz0oPzpcXGR7M30pKyQpKD8hXikvZywgJywnKTtcbiAgICAgIHN0cmFic251bSA9IGFic251bS50b1N0cmluZygpO1xuICAgICAgaWYgKHN0cmFic251bS5sZW5ndGggPiBpbnRudW0ubGVuZ3RoKSB7XG4gICAgICAgIHJldCArPSBzdHJhYnNudW0uc2xpY2UoaW50bnVtLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJy0nO1xuICAgIH1cbiAgfTtcblxuICBNb3JyaXMucGFkMiA9IGZ1bmN0aW9uKG51bWJlcikge1xuICAgIHJldHVybiAobnVtYmVyIDwgMTAgPyAnMCcgOiAnJykgKyBudW1iZXI7XG4gIH07XG5cbiAgTW9ycmlzLkdyaWQgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdyaWQsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBHcmlkKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMucmVzaXplSGFuZGxlciA9IF9fYmluZCh0aGlzLnJlc2l6ZUhhbmRsZXIsIHRoaXMpO1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLmVsID0gJChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcHRpb25zLmVsZW1lbnQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWwgPSAkKG9wdGlvbnMuZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBpZiAoKHRoaXMuZWwgPT0gbnVsbCkgfHwgdGhpcy5lbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR3JhcGggY29udGFpbmVyIGVsZW1lbnQgbm90IGZvdW5kXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZWwuY3NzKCdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgICAgICB0aGlzLmVsLmNzcygncG9zaXRpb24nLCAncmVsYXRpdmUnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCB0aGlzLmdyaWREZWZhdWx0cywgdGhpcy5kZWZhdWx0cyB8fCB7fSwgb3B0aW9ucyk7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy51bml0cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnBvc3RVbml0cyA9IG9wdGlvbnMudW5pdHM7XG4gICAgICB9XG4gICAgICB0aGlzLnJhcGhhZWwgPSBuZXcgUmFwaGFlbCh0aGlzLmVsWzBdKTtcbiAgICAgIHRoaXMuZWxlbWVudFdpZHRoID0gbnVsbDtcbiAgICAgIHRoaXMuZWxlbWVudEhlaWdodCA9IG51bGw7XG4gICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICB0aGlzLnNlbGVjdEZyb20gPSBudWxsO1xuICAgICAgaWYgKHRoaXMuaW5pdCkge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0RGF0YSh0aGlzLm9wdGlvbnMuZGF0YSk7XG4gICAgICB0aGlzLmVsLmJpbmQoJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB2YXIgbGVmdCwgb2Zmc2V0LCByaWdodCwgd2lkdGgsIHg7XG4gICAgICAgIG9mZnNldCA9IF90aGlzLmVsLm9mZnNldCgpO1xuICAgICAgICB4ID0gZXZ0LnBhZ2VYIC0gb2Zmc2V0LmxlZnQ7XG4gICAgICAgIGlmIChfdGhpcy5zZWxlY3RGcm9tKSB7XG4gICAgICAgICAgbGVmdCA9IF90aGlzLmRhdGFbX3RoaXMuaGl0VGVzdChNYXRoLm1pbih4LCBfdGhpcy5zZWxlY3RGcm9tKSldLl94O1xuICAgICAgICAgIHJpZ2h0ID0gX3RoaXMuZGF0YVtfdGhpcy5oaXRUZXN0KE1hdGgubWF4KHgsIF90aGlzLnNlbGVjdEZyb20pKV0uX3g7XG4gICAgICAgICAgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnNlbGVjdGlvblJlY3QuYXR0cih7XG4gICAgICAgICAgICB4OiBsZWZ0LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmZpcmUoJ2hvdmVybW92ZScsIHgsIGV2dC5wYWdlWSAtIG9mZnNldC50b3ApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZWwuYmluZCgnbW91c2VsZWF2ZScsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBpZiAoX3RoaXMuc2VsZWN0RnJvbSkge1xuICAgICAgICAgIF90aGlzLnNlbGVjdGlvblJlY3QuaGlkZSgpO1xuICAgICAgICAgIF90aGlzLnNlbGVjdEZyb20gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcy5maXJlKCdob3Zlcm91dCcpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmVsLmJpbmQoJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHZhciBvZmZzZXQsIHRvdWNoO1xuICAgICAgICB0b3VjaCA9IGV2dC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0gfHwgZXZ0Lm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgIG9mZnNldCA9IF90aGlzLmVsLm9mZnNldCgpO1xuICAgICAgICByZXR1cm4gX3RoaXMuZmlyZSgnaG92ZXJtb3ZlJywgdG91Y2gucGFnZVggLSBvZmZzZXQubGVmdCwgdG91Y2gucGFnZVkgLSBvZmZzZXQudG9wKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbC5iaW5kKCdjbGljaycsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB2YXIgb2Zmc2V0O1xuICAgICAgICBvZmZzZXQgPSBfdGhpcy5lbC5vZmZzZXQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzLmZpcmUoJ2dyaWRjbGljaycsIGV2dC5wYWdlWCAtIG9mZnNldC5sZWZ0LCBldnQucGFnZVkgLSBvZmZzZXQudG9wKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZVNlbGVjdCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblJlY3QgPSB0aGlzLnJhcGhhZWwucmVjdCgwLCAwLCAwLCB0aGlzLmVsLmlubmVySGVpZ2h0KCkpLmF0dHIoe1xuICAgICAgICAgIGZpbGw6IHRoaXMub3B0aW9ucy5yYW5nZVNlbGVjdENvbG9yLFxuICAgICAgICAgIHN0cm9rZTogZmFsc2VcbiAgICAgICAgfSkudG9CYWNrKCkuaGlkZSgpO1xuICAgICAgICB0aGlzLmVsLmJpbmQoJ21vdXNlZG93bicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgIHZhciBvZmZzZXQ7XG4gICAgICAgICAgb2Zmc2V0ID0gX3RoaXMuZWwub2Zmc2V0KCk7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnN0YXJ0UmFuZ2UoZXZ0LnBhZ2VYIC0gb2Zmc2V0LmxlZnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbC5iaW5kKCdtb3VzZXVwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgdmFyIG9mZnNldDtcbiAgICAgICAgICBvZmZzZXQgPSBfdGhpcy5lbC5vZmZzZXQoKTtcbiAgICAgICAgICBfdGhpcy5lbmRSYW5nZShldnQucGFnZVggLSBvZmZzZXQubGVmdCk7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmZpcmUoJ2hvdmVybW92ZScsIGV2dC5wYWdlWCAtIG9mZnNldC5sZWZ0LCBldnQucGFnZVkgLSBvZmZzZXQudG9wKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJlc2l6ZSkge1xuICAgICAgICAkKHdpbmRvdykuYmluZCgncmVzaXplJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgaWYgKF90aGlzLnRpbWVvdXRJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXRJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfdGhpcy50aW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dChfdGhpcy5yZXNpemVIYW5kbGVyLCAxMDApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZWwuY3NzKCctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InLCAncmdiYSgwLDAsMCwwKScpO1xuICAgICAgaWYgKHRoaXMucG9zdEluaXQpIHtcbiAgICAgICAgdGhpcy5wb3N0SW5pdCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEdyaWQucHJvdG90eXBlLmdyaWREZWZhdWx0cyA9IHtcbiAgICAgIGRhdGVGb3JtYXQ6IG51bGwsXG4gICAgICBheGVzOiB0cnVlLFxuICAgICAgZ3JpZDogdHJ1ZSxcbiAgICAgIGdyaWRMaW5lQ29sb3I6ICcjYWFhJyxcbiAgICAgIGdyaWRTdHJva2VXaWR0aDogMC41LFxuICAgICAgZ3JpZFRleHRDb2xvcjogJyM4ODgnLFxuICAgICAgZ3JpZFRleHRTaXplOiAxMixcbiAgICAgIGdyaWRUZXh0RmFtaWx5OiAnc2Fucy1zZXJpZicsXG4gICAgICBncmlkVGV4dFdlaWdodDogJ25vcm1hbCcsXG4gICAgICBoaWRlSG92ZXI6IGZhbHNlLFxuICAgICAgeUxhYmVsRm9ybWF0OiBudWxsLFxuICAgICAgeExhYmVsQW5nbGU6IDAsXG4gICAgICBudW1MaW5lczogNSxcbiAgICAgIHBhZGRpbmc6IDI1LFxuICAgICAgcGFyc2VUaW1lOiB0cnVlLFxuICAgICAgcG9zdFVuaXRzOiAnJyxcbiAgICAgIHByZVVuaXRzOiAnJyxcbiAgICAgIHltYXg6ICdhdXRvJyxcbiAgICAgIHltaW46ICdhdXRvIDAnLFxuICAgICAgZ29hbHM6IFtdLFxuICAgICAgZ29hbFN0cm9rZVdpZHRoOiAxLjAsXG4gICAgICBnb2FsTGluZUNvbG9yczogWycjNjY2NjMzJywgJyM5OTk5NjYnLCAnI2NjNjY2NicsICcjNjYzMzMzJ10sXG4gICAgICBldmVudHM6IFtdLFxuICAgICAgZXZlbnRTdHJva2VXaWR0aDogMS4wLFxuICAgICAgZXZlbnRMaW5lQ29sb3JzOiBbJyMwMDVhMDQnLCAnI2NjZmZiYicsICcjM2E1ZjBiJywgJyMwMDU1MDInXSxcbiAgICAgIHJhbmdlU2VsZWN0OiBudWxsLFxuICAgICAgcmFuZ2VTZWxlY3RDb2xvcjogJyNlZWYnLFxuICAgICAgcmVzaXplOiBmYWxzZVxuICAgIH07XG5cbiAgICBHcmlkLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24oZGF0YSwgcmVkcmF3KSB7XG4gICAgICB2YXIgZSwgaWR4LCBpbmRleCwgbWF4R29hbCwgbWluR29hbCwgcmV0LCByb3csIHN0ZXAsIHRvdGFsLCB5LCB5a2V5LCB5bWF4LCB5bWluLCB5dmFsLCBfcmVmO1xuICAgICAgaWYgKHJlZHJhdyA9PSBudWxsKSB7XG4gICAgICAgIHJlZHJhdyA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLm9wdGlvbnMuZGF0YSA9IGRhdGE7XG4gICAgICBpZiAoKGRhdGEgPT0gbnVsbCkgfHwgZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIHRoaXMucmFwaGFlbC5jbGVhcigpO1xuICAgICAgICBpZiAodGhpcy5ob3ZlciAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5ob3Zlci5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgeW1heCA9IHRoaXMuY3VtdWxhdGl2ZSA/IDAgOiBudWxsO1xuICAgICAgeW1pbiA9IHRoaXMuY3VtdWxhdGl2ZSA/IDAgOiBudWxsO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5nb2Fscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG1pbkdvYWwgPSBNYXRoLm1pbi5hcHBseShNYXRoLCB0aGlzLm9wdGlvbnMuZ29hbHMpO1xuICAgICAgICBtYXhHb2FsID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgdGhpcy5vcHRpb25zLmdvYWxzKTtcbiAgICAgICAgeW1pbiA9IHltaW4gIT0gbnVsbCA/IE1hdGgubWluKHltaW4sIG1pbkdvYWwpIDogbWluR29hbDtcbiAgICAgICAgeW1heCA9IHltYXggIT0gbnVsbCA/IE1hdGgubWF4KHltYXgsIG1heEdvYWwpIDogbWF4R29hbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGF0YSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVzdWx0cztcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChpbmRleCA9IF9pID0gMCwgX2xlbiA9IGRhdGEubGVuZ3RoOyBfaSA8IF9sZW47IGluZGV4ID0gKytfaSkge1xuICAgICAgICAgIHJvdyA9IGRhdGFbaW5kZXhdO1xuICAgICAgICAgIHJldCA9IHtcbiAgICAgICAgICAgIHNyYzogcm93XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXQubGFiZWwgPSByb3dbdGhpcy5vcHRpb25zLnhrZXldO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGFyc2VUaW1lKSB7XG4gICAgICAgICAgICByZXQueCA9IE1vcnJpcy5wYXJzZURhdGUocmV0LmxhYmVsKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGF0ZUZvcm1hdCkge1xuICAgICAgICAgICAgICByZXQubGFiZWwgPSB0aGlzLm9wdGlvbnMuZGF0ZUZvcm1hdChyZXQueCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXQubGFiZWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIHJldC5sYWJlbCA9IG5ldyBEYXRlKHJldC5sYWJlbCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0LnggPSBpbmRleDtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMueExhYmVsRm9ybWF0KSB7XG4gICAgICAgICAgICAgIHJldC5sYWJlbCA9IHRoaXMub3B0aW9ucy54TGFiZWxGb3JtYXQocmV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdG90YWwgPSAwO1xuICAgICAgICAgIHJldC55ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF9qLCBfbGVuMSwgX3JlZiwgX3Jlc3VsdHMxO1xuICAgICAgICAgICAgX3JlZiA9IHRoaXMub3B0aW9ucy55a2V5cztcbiAgICAgICAgICAgIF9yZXN1bHRzMSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpZHggPSBfaiA9IDAsIF9sZW4xID0gX3JlZi5sZW5ndGg7IF9qIDwgX2xlbjE7IGlkeCA9ICsrX2opIHtcbiAgICAgICAgICAgICAgeWtleSA9IF9yZWZbaWR4XTtcbiAgICAgICAgICAgICAgeXZhbCA9IHJvd1t5a2V5XTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB5dmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHl2YWwgPSBwYXJzZUZsb2F0KHl2YWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICgoeXZhbCAhPSBudWxsKSAmJiB0eXBlb2YgeXZhbCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB5dmFsID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoeXZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VtdWxhdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgdG90YWwgKz0geXZhbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKHltYXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB5bWF4ID0gTWF0aC5tYXgoeXZhbCwgeW1heCk7XG4gICAgICAgICAgICAgICAgICAgIHltaW4gPSBNYXRoLm1pbih5dmFsLCB5bWluKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHltYXggPSB5bWluID0geXZhbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuY3VtdWxhdGl2ZSAmJiAodG90YWwgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICB5bWF4ID0gTWF0aC5tYXgodG90YWwsIHltYXgpO1xuICAgICAgICAgICAgICAgIHltaW4gPSBNYXRoLm1pbih0b3RhbCwgeW1pbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX3Jlc3VsdHMxLnB1c2goeXZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3Jlc3VsdHMxO1xuICAgICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChyZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBhcnNlVGltZSkge1xuICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLmRhdGEuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIChhLnggPiBiLngpIC0gKGIueCA+IGEueCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy54bWluID0gdGhpcy5kYXRhWzBdLng7XG4gICAgICB0aGlzLnhtYXggPSB0aGlzLmRhdGFbdGhpcy5kYXRhLmxlbmd0aCAtIDFdLng7XG4gICAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ldmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBhcnNlVGltZSkge1xuICAgICAgICAgIHRoaXMuZXZlbnRzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgICAgIF9yZWYgPSB0aGlzLm9wdGlvbnMuZXZlbnRzO1xuICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgICBlID0gX3JlZltfaV07XG4gICAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goTW9ycmlzLnBhcnNlRGF0ZShlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmV2ZW50cyA9IHRoaXMub3B0aW9ucy5ldmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54bWF4ID0gTWF0aC5tYXgodGhpcy54bWF4LCBNYXRoLm1heC5hcHBseShNYXRoLCB0aGlzLmV2ZW50cykpO1xuICAgICAgICB0aGlzLnhtaW4gPSBNYXRoLm1pbih0aGlzLnhtaW4sIE1hdGgubWluLmFwcGx5KE1hdGgsIHRoaXMuZXZlbnRzKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy54bWluID09PSB0aGlzLnhtYXgpIHtcbiAgICAgICAgdGhpcy54bWluIC09IDE7XG4gICAgICAgIHRoaXMueG1heCArPSAxO1xuICAgICAgfVxuICAgICAgdGhpcy55bWluID0gdGhpcy55Ym91bmRhcnkoJ21pbicsIHltaW4pO1xuICAgICAgdGhpcy55bWF4ID0gdGhpcy55Ym91bmRhcnkoJ21heCcsIHltYXgpO1xuICAgICAgaWYgKHRoaXMueW1pbiA9PT0gdGhpcy55bWF4KSB7XG4gICAgICAgIGlmICh5bWluKSB7XG4gICAgICAgICAgdGhpcy55bWluIC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy55bWF4ICs9IDE7XG4gICAgICB9XG4gICAgICBpZiAoKChfcmVmID0gdGhpcy5vcHRpb25zLmF4ZXMpID09PSB0cnVlIHx8IF9yZWYgPT09ICdib3RoJyB8fCBfcmVmID09PSAneScpIHx8IHRoaXMub3B0aW9ucy5ncmlkID09PSB0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMueW1heCA9PT0gdGhpcy5ncmlkRGVmYXVsdHMueW1heCAmJiB0aGlzLm9wdGlvbnMueW1pbiA9PT0gdGhpcy5ncmlkRGVmYXVsdHMueW1pbikge1xuICAgICAgICAgIHRoaXMuZ3JpZCA9IHRoaXMuYXV0b0dyaWRMaW5lcyh0aGlzLnltaW4sIHRoaXMueW1heCwgdGhpcy5vcHRpb25zLm51bUxpbmVzKTtcbiAgICAgICAgICB0aGlzLnltaW4gPSBNYXRoLm1pbih0aGlzLnltaW4sIHRoaXMuZ3JpZFswXSk7XG4gICAgICAgICAgdGhpcy55bWF4ID0gTWF0aC5tYXgodGhpcy55bWF4LCB0aGlzLmdyaWRbdGhpcy5ncmlkLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGVwID0gKHRoaXMueW1heCAtIHRoaXMueW1pbikgLyAodGhpcy5vcHRpb25zLm51bUxpbmVzIC0gMSk7XG4gICAgICAgICAgdGhpcy5ncmlkID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF9pLCBfcmVmMSwgX3JlZjIsIF9yZXN1bHRzO1xuICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoeSA9IF9pID0gX3JlZjEgPSB0aGlzLnltaW4sIF9yZWYyID0gdGhpcy55bWF4OyBzdGVwID4gMCA/IF9pIDw9IF9yZWYyIDogX2kgPj0gX3JlZjI7IHkgPSBfaSArPSBzdGVwKSB7XG4gICAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICBpZiAocmVkcmF3KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZHJhdygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBHcmlkLnByb3RvdHlwZS55Ym91bmRhcnkgPSBmdW5jdGlvbihib3VuZGFyeVR5cGUsIGN1cnJlbnRWYWx1ZSkge1xuICAgICAgdmFyIGJvdW5kYXJ5T3B0aW9uLCBzdWdnZXN0ZWRWYWx1ZTtcbiAgICAgIGJvdW5kYXJ5T3B0aW9uID0gdGhpcy5vcHRpb25zW1wieVwiICsgYm91bmRhcnlUeXBlXTtcbiAgICAgIGlmICh0eXBlb2YgYm91bmRhcnlPcHRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChib3VuZGFyeU9wdGlvbi5zbGljZSgwLCA0KSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgaWYgKGJvdW5kYXJ5T3B0aW9uLmxlbmd0aCA+IDUpIHtcbiAgICAgICAgICAgIHN1Z2dlc3RlZFZhbHVlID0gcGFyc2VJbnQoYm91bmRhcnlPcHRpb24uc2xpY2UoNSksIDEwKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gc3VnZ2VzdGVkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTWF0aFtib3VuZGFyeVR5cGVdKGN1cnJlbnRWYWx1ZSwgc3VnZ2VzdGVkVmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoYm91bmRhcnlPcHRpb24sIDEwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJvdW5kYXJ5T3B0aW9uO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBHcmlkLnByb3RvdHlwZS5hdXRvR3JpZExpbmVzID0gZnVuY3Rpb24oeW1pbiwgeW1heCwgbmxpbmVzKSB7XG4gICAgICB2YXIgZ21heCwgZ21pbiwgZ3JpZCwgc21hZywgc3Bhbiwgc3RlcCwgdW5pdCwgeSwgeW1hZztcbiAgICAgIHNwYW4gPSB5bWF4IC0geW1pbjtcbiAgICAgIHltYWcgPSBNYXRoLmZsb29yKE1hdGgubG9nKHNwYW4pIC8gTWF0aC5sb2coMTApKTtcbiAgICAgIHVuaXQgPSBNYXRoLnBvdygxMCwgeW1hZyk7XG4gICAgICBnbWluID0gTWF0aC5mbG9vcih5bWluIC8gdW5pdCkgKiB1bml0O1xuICAgICAgZ21heCA9IE1hdGguY2VpbCh5bWF4IC8gdW5pdCkgKiB1bml0O1xuICAgICAgc3RlcCA9IChnbWF4IC0gZ21pbikgLyAobmxpbmVzIC0gMSk7XG4gICAgICBpZiAodW5pdCA9PT0gMSAmJiBzdGVwID4gMSAmJiBNYXRoLmNlaWwoc3RlcCkgIT09IHN0ZXApIHtcbiAgICAgICAgc3RlcCA9IE1hdGguY2VpbChzdGVwKTtcbiAgICAgICAgZ21heCA9IGdtaW4gKyBzdGVwICogKG5saW5lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKGdtaW4gPCAwICYmIGdtYXggPiAwKSB7XG4gICAgICAgIGdtaW4gPSBNYXRoLmZsb29yKHltaW4gLyBzdGVwKSAqIHN0ZXA7XG4gICAgICAgIGdtYXggPSBNYXRoLmNlaWwoeW1heCAvIHN0ZXApICogc3RlcDtcbiAgICAgIH1cbiAgICAgIGlmIChzdGVwIDwgMSkge1xuICAgICAgICBzbWFnID0gTWF0aC5mbG9vcihNYXRoLmxvZyhzdGVwKSAvIE1hdGgubG9nKDEwKSk7XG4gICAgICAgIGdyaWQgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9pLCBfcmVzdWx0cztcbiAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAoeSA9IF9pID0gZ21pbjsgc3RlcCA+IDAgPyBfaSA8PSBnbWF4IDogX2kgPj0gZ21heDsgeSA9IF9pICs9IHN0ZXApIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2gocGFyc2VGbG9hdCh5LnRvRml4ZWQoMSAtIHNtYWcpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgfSkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyaWQgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9pLCBfcmVzdWx0cztcbiAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAoeSA9IF9pID0gZ21pbjsgc3RlcCA+IDAgPyBfaSA8PSBnbWF4IDogX2kgPj0gZ21heDsgeSA9IF9pICs9IHN0ZXApIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgfSkoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncmlkO1xuICAgIH07XG5cbiAgICBHcmlkLnByb3RvdHlwZS5fY2FsYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGJvdHRvbU9mZnNldHMsIGdyaWRMaW5lLCBoLCBpLCB3LCB5TGFiZWxXaWR0aHMsIF9yZWYsIF9yZWYxO1xuICAgICAgdyA9IHRoaXMuZWwud2lkdGgoKTtcbiAgICAgIGggPSB0aGlzLmVsLmhlaWdodCgpO1xuICAgICAgaWYgKHRoaXMuZWxlbWVudFdpZHRoICE9PSB3IHx8IHRoaXMuZWxlbWVudEhlaWdodCAhPT0gaCB8fCB0aGlzLmRpcnR5KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudFdpZHRoID0gdztcbiAgICAgICAgdGhpcy5lbGVtZW50SGVpZ2h0ID0gaDtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlZnQgPSB0aGlzLm9wdGlvbnMucGFkZGluZztcbiAgICAgICAgdGhpcy5yaWdodCA9IHRoaXMuZWxlbWVudFdpZHRoIC0gdGhpcy5vcHRpb25zLnBhZGRpbmc7XG4gICAgICAgIHRoaXMudG9wID0gdGhpcy5vcHRpb25zLnBhZGRpbmc7XG4gICAgICAgIHRoaXMuYm90dG9tID0gdGhpcy5lbGVtZW50SGVpZ2h0IC0gdGhpcy5vcHRpb25zLnBhZGRpbmc7XG4gICAgICAgIGlmICgoX3JlZiA9IHRoaXMub3B0aW9ucy5heGVzKSA9PT0gdHJ1ZSB8fCBfcmVmID09PSAnYm90aCcgfHwgX3JlZiA9PT0gJ3knKSB7XG4gICAgICAgICAgeUxhYmVsV2lkdGhzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICAgICAgICBfcmVmMSA9IHRoaXMuZ3JpZDtcbiAgICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICAgIGdyaWRMaW5lID0gX3JlZjFbX2ldO1xuICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMubWVhc3VyZVRleHQodGhpcy55QXhpc0Zvcm1hdChncmlkTGluZSkpLndpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMubGVmdCArPSBNYXRoLm1heC5hcHBseShNYXRoLCB5TGFiZWxXaWR0aHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoX3JlZjEgPSB0aGlzLm9wdGlvbnMuYXhlcykgPT09IHRydWUgfHwgX3JlZjEgPT09ICdib3RoJyB8fCBfcmVmMSA9PT0gJ3gnKSB7XG4gICAgICAgICAgYm90dG9tT2Zmc2V0cyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBfaSwgX3JlZjIsIF9yZXN1bHRzO1xuICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IF9pID0gMCwgX3JlZjIgPSB0aGlzLmRhdGEubGVuZ3RoOyAwIDw9IF9yZWYyID8gX2kgPCBfcmVmMiA6IF9pID4gX3JlZjI7IGkgPSAwIDw9IF9yZWYyID8gKytfaSA6IC0tX2kpIHtcbiAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLm1lYXN1cmVUZXh0KHRoaXMuZGF0YVtpXS50ZXh0LCAtdGhpcy5vcHRpb25zLnhMYWJlbEFuZ2xlKS5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5ib3R0b20gLT0gTWF0aC5tYXguYXBwbHkoTWF0aCwgYm90dG9tT2Zmc2V0cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53aWR0aCA9IE1hdGgubWF4KDEsIHRoaXMucmlnaHQgLSB0aGlzLmxlZnQpO1xuICAgICAgICB0aGlzLmhlaWdodCA9IE1hdGgubWF4KDEsIHRoaXMuYm90dG9tIC0gdGhpcy50b3ApO1xuICAgICAgICB0aGlzLmR4ID0gdGhpcy53aWR0aCAvICh0aGlzLnhtYXggLSB0aGlzLnhtaW4pO1xuICAgICAgICB0aGlzLmR5ID0gdGhpcy5oZWlnaHQgLyAodGhpcy55bWF4IC0gdGhpcy55bWluKTtcbiAgICAgICAgaWYgKHRoaXMuY2FsYykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNhbGMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBHcmlkLnByb3RvdHlwZS50cmFuc1kgPSBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4gdGhpcy5ib3R0b20gLSAoeSAtIHRoaXMueW1pbikgKiB0aGlzLmR5O1xuICAgIH07XG5cbiAgICBHcmlkLnByb3RvdHlwZS50cmFuc1ggPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gKHRoaXMubGVmdCArIHRoaXMucmlnaHQpIC8gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQgKyAoeCAtIHRoaXMueG1pbikgKiB0aGlzLmR4O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBHcmlkLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucmFwaGFlbC5jbGVhcigpO1xuICAgICAgdGhpcy5fY2FsYygpO1xuICAgICAgdGhpcy5kcmF3R3JpZCgpO1xuICAgICAgdGhpcy5kcmF3R29hbHMoKTtcbiAgICAgIHRoaXMuZHJhd0V2ZW50cygpO1xuICAgICAgaWYgKHRoaXMuZHJhdykge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEdyaWQucHJvdG90eXBlLm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24odGV4dCwgYW5nbGUpIHtcbiAgICAgIHZhciByZXQsIHR0O1xuICAgICAgaWYgKGFuZ2xlID09IG51bGwpIHtcbiAgICAgICAgYW5nbGUgPSAwO1xuICAgICAgfVxuICAgICAgdHQgPSB0aGlzLnJhcGhhZWwudGV4dCgxMDAsIDEwMCwgdGV4dCkuYXR0cignZm9udC1zaXplJywgdGhpcy5vcHRpb25zLmdyaWRUZXh0U2l6ZSkuYXR0cignZm9udC1mYW1pbHknLCB0aGlzLm9wdGlvbnMuZ3JpZFRleHRGYW1pbHkpLmF0dHIoJ2ZvbnQtd2VpZ2h0JywgdGhpcy5vcHRpb25zLmdyaWRUZXh0V2VpZ2h0KS5yb3RhdGUoYW5nbGUpO1xuICAgICAgcmV0ID0gdHQuZ2V0QkJveCgpO1xuICAgICAgdHQucmVtb3ZlKCk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBHcmlkLnByb3RvdHlwZS55QXhpc0Zvcm1hdCA9IGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICByZXR1cm4gdGhpcy55TGFiZWxGb3JtYXQobGFiZWwpO1xuICAgIH07XG5cbiAgICBHcmlkLnByb3RvdHlwZS55TGFiZWxGb3JtYXQgPSBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMueUxhYmVsRm9ybWF0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMueUxhYmVsRm9ybWF0KGxhYmVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgdGhpcy5vcHRpb25zLnByZVVuaXRzICsgKE1vcnJpcy5jb21tYXMobGFiZWwpKSArIHRoaXMub3B0aW9ucy5wb3N0VW5pdHM7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEdyaWQucHJvdG90eXBlLmRyYXdHcmlkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGluZVksIHksIF9pLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3JlZjIsIF9yZXN1bHRzO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ncmlkID09PSBmYWxzZSAmJiAoKF9yZWYgPSB0aGlzLm9wdGlvbnMuYXhlcykgIT09IHRydWUgJiYgX3JlZiAhPT0gJ2JvdGgnICYmIF9yZWYgIT09ICd5JykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX3JlZjEgPSB0aGlzLmdyaWQ7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBsaW5lWSA9IF9yZWYxW19pXTtcbiAgICAgICAgeSA9IHRoaXMudHJhbnNZKGxpbmVZKTtcbiAgICAgICAgaWYgKChfcmVmMiA9IHRoaXMub3B0aW9ucy5heGVzKSA9PT0gdHJ1ZSB8fCBfcmVmMiA9PT0gJ2JvdGgnIHx8IF9yZWYyID09PSAneScpIHtcbiAgICAgICAgICB0aGlzLmRyYXdZQXhpc0xhYmVsKHRoaXMubGVmdCAtIHRoaXMub3B0aW9ucy5wYWRkaW5nIC8gMiwgeSwgdGhpcy55QXhpc0Zvcm1hdChsaW5lWSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ3JpZCkge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy5kcmF3R3JpZExpbmUoXCJNXCIgKyB0aGlzLmxlZnQgKyBcIixcIiArIHkgKyBcIkhcIiArICh0aGlzLmxlZnQgKyB0aGlzLndpZHRoKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBHcmlkLnByb3RvdHlwZS5kcmF3R29hbHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb2xvciwgZ29hbCwgaSwgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgX3JlZiA9IHRoaXMub3B0aW9ucy5nb2FscztcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKGkgPSBfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBpID0gKytfaSkge1xuICAgICAgICBnb2FsID0gX3JlZltpXTtcbiAgICAgICAgY29sb3IgPSB0aGlzLm9wdGlvbnMuZ29hbExpbmVDb2xvcnNbaSAlIHRoaXMub3B0aW9ucy5nb2FsTGluZUNvbG9ycy5sZW5ndGhdO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMuZHJhd0dvYWwoZ29hbCwgY29sb3IpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgR3JpZC5wcm90b3R5cGUuZHJhd0V2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvbG9yLCBldmVudCwgaSwgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgX3JlZiA9IHRoaXMuZXZlbnRzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoaSA9IF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IGkgPSArK19pKSB7XG4gICAgICAgIGV2ZW50ID0gX3JlZltpXTtcbiAgICAgICAgY29sb3IgPSB0aGlzLm9wdGlvbnMuZXZlbnRMaW5lQ29sb3JzW2kgJSB0aGlzLm9wdGlvbnMuZXZlbnRMaW5lQ29sb3JzLmxlbmd0aF07XG4gICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy5kcmF3RXZlbnQoZXZlbnQsIGNvbG9yKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIEdyaWQucHJvdG90eXBlLmRyYXdHb2FsID0gZnVuY3Rpb24oZ29hbCwgY29sb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhcGhhZWwucGF0aChcIk1cIiArIHRoaXMubGVmdCArIFwiLFwiICsgKHRoaXMudHJhbnNZKGdvYWwpKSArIFwiSFwiICsgdGhpcy5yaWdodCkuYXR0cignc3Ryb2tlJywgY29sb3IpLmF0dHIoJ3N0cm9rZS13aWR0aCcsIHRoaXMub3B0aW9ucy5nb2FsU3Ryb2tlV2lkdGgpO1xuICAgIH07XG5cbiAgICBHcmlkLnByb3RvdHlwZS5kcmF3RXZlbnQgPSBmdW5jdGlvbihldmVudCwgY29sb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhcGhhZWwucGF0aChcIk1cIiArICh0aGlzLnRyYW5zWChldmVudCkpICsgXCIsXCIgKyB0aGlzLmJvdHRvbSArIFwiVlwiICsgdGhpcy50b3ApLmF0dHIoJ3N0cm9rZScsIGNvbG9yKS5hdHRyKCdzdHJva2Utd2lkdGgnLCB0aGlzLm9wdGlvbnMuZXZlbnRTdHJva2VXaWR0aCk7XG4gICAgfTtcblxuICAgIEdyaWQucHJvdG90eXBlLmRyYXdZQXhpc0xhYmVsID0gZnVuY3Rpb24oeFBvcywgeVBvcywgdGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMucmFwaGFlbC50ZXh0KHhQb3MsIHlQb3MsIHRleHQpLmF0dHIoJ2ZvbnQtc2l6ZScsIHRoaXMub3B0aW9ucy5ncmlkVGV4dFNpemUpLmF0dHIoJ2ZvbnQtZmFtaWx5JywgdGhpcy5vcHRpb25zLmdyaWRUZXh0RmFtaWx5KS5hdHRyKCdmb250LXdlaWdodCcsIHRoaXMub3B0aW9ucy5ncmlkVGV4dFdlaWdodCkuYXR0cignZmlsbCcsIHRoaXMub3B0aW9ucy5ncmlkVGV4dENvbG9yKS5hdHRyKCd0ZXh0LWFuY2hvcicsICdlbmQnKTtcbiAgICB9O1xuXG4gICAgR3JpZC5wcm90b3R5cGUuZHJhd0dyaWRMaW5lID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucmFwaGFlbC5wYXRoKHBhdGgpLmF0dHIoJ3N0cm9rZScsIHRoaXMub3B0aW9ucy5ncmlkTGluZUNvbG9yKS5hdHRyKCdzdHJva2Utd2lkdGgnLCB0aGlzLm9wdGlvbnMuZ3JpZFN0cm9rZVdpZHRoKTtcbiAgICB9O1xuXG4gICAgR3JpZC5wcm90b3R5cGUuc3RhcnRSYW5nZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHRoaXMuaG92ZXIuaGlkZSgpO1xuICAgICAgdGhpcy5zZWxlY3RGcm9tID0geDtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvblJlY3QuYXR0cih7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHdpZHRoOiAwXG4gICAgICB9KS5zaG93KCk7XG4gICAgfTtcblxuICAgIEdyaWQucHJvdG90eXBlLmVuZFJhbmdlID0gZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIGVuZCwgc3RhcnQ7XG4gICAgICBpZiAodGhpcy5zZWxlY3RGcm9tKSB7XG4gICAgICAgIHN0YXJ0ID0gTWF0aC5taW4odGhpcy5zZWxlY3RGcm9tLCB4KTtcbiAgICAgICAgZW5kID0gTWF0aC5tYXgodGhpcy5zZWxlY3RGcm9tLCB4KTtcbiAgICAgICAgdGhpcy5vcHRpb25zLnJhbmdlU2VsZWN0LmNhbGwodGhpcy5lbCwge1xuICAgICAgICAgIHN0YXJ0OiB0aGlzLmRhdGFbdGhpcy5oaXRUZXN0KHN0YXJ0KV0ueCxcbiAgICAgICAgICBlbmQ6IHRoaXMuZGF0YVt0aGlzLmhpdFRlc3QoZW5kKV0ueFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0RnJvbSA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEdyaWQucHJvdG90eXBlLnJlc2l6ZUhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudGltZW91dElkID0gbnVsbDtcbiAgICAgIHRoaXMucmFwaGFlbC5zZXRTaXplKHRoaXMuZWwud2lkdGgoKSwgdGhpcy5lbC5oZWlnaHQoKSk7XG4gICAgICByZXR1cm4gdGhpcy5yZWRyYXcoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEdyaWQ7XG5cbiAgfSkoTW9ycmlzLkV2ZW50RW1pdHRlcik7XG5cbiAgTW9ycmlzLnBhcnNlRGF0ZSA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICB2YXIgaXNlY3MsIG0sIG1zZWNzLCBuLCBvLCBvZmZzZXRtaW5zLCBwLCBxLCByLCByZXQsIHNlY3M7XG4gICAgaWYgKHR5cGVvZiBkYXRlID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuICAgIG0gPSBkYXRlLm1hdGNoKC9eKFxcZCspIFEoXFxkKSQvKTtcbiAgICBuID0gZGF0ZS5tYXRjaCgvXihcXGQrKS0oXFxkKykkLyk7XG4gICAgbyA9IGRhdGUubWF0Y2goL14oXFxkKyktKFxcZCspLShcXGQrKSQvKTtcbiAgICBwID0gZGF0ZS5tYXRjaCgvXihcXGQrKSBXKFxcZCspJC8pO1xuICAgIHEgPSBkYXRlLm1hdGNoKC9eKFxcZCspLShcXGQrKS0oXFxkKylbIFRdKFxcZCspOihcXGQrKShafChbKy1dKShcXGRcXGQpOj8oXFxkXFxkKSk/JC8pO1xuICAgIHIgPSBkYXRlLm1hdGNoKC9eKFxcZCspLShcXGQrKS0oXFxkKylbIFRdKFxcZCspOihcXGQrKTooXFxkKyhcXC5cXGQrKT8pKFp8KFsrLV0pKFxcZFxcZCk6PyhcXGRcXGQpKT8kLyk7XG4gICAgaWYgKG0pIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShwYXJzZUludChtWzFdLCAxMCksIHBhcnNlSW50KG1bMl0sIDEwKSAqIDMgLSAxLCAxKS5nZXRUaW1lKCk7XG4gICAgfSBlbHNlIGlmIChuKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUocGFyc2VJbnQoblsxXSwgMTApLCBwYXJzZUludChuWzJdLCAxMCkgLSAxLCAxKS5nZXRUaW1lKCk7XG4gICAgfSBlbHNlIGlmIChvKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUocGFyc2VJbnQob1sxXSwgMTApLCBwYXJzZUludChvWzJdLCAxMCkgLSAxLCBwYXJzZUludChvWzNdLCAxMCkpLmdldFRpbWUoKTtcbiAgICB9IGVsc2UgaWYgKHApIHtcbiAgICAgIHJldCA9IG5ldyBEYXRlKHBhcnNlSW50KHBbMV0sIDEwKSwgMCwgMSk7XG4gICAgICBpZiAocmV0LmdldERheSgpICE9PSA0KSB7XG4gICAgICAgIHJldC5zZXRNb250aCgwLCAxICsgKCg0IC0gcmV0LmdldERheSgpKSArIDcpICUgNyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0LmdldFRpbWUoKSArIHBhcnNlSW50KHBbMl0sIDEwKSAqIDYwNDgwMDAwMDtcbiAgICB9IGVsc2UgaWYgKHEpIHtcbiAgICAgIGlmICghcVs2XSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUocGFyc2VJbnQocVsxXSwgMTApLCBwYXJzZUludChxWzJdLCAxMCkgLSAxLCBwYXJzZUludChxWzNdLCAxMCksIHBhcnNlSW50KHFbNF0sIDEwKSwgcGFyc2VJbnQocVs1XSwgMTApKS5nZXRUaW1lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXRtaW5zID0gMDtcbiAgICAgICAgaWYgKHFbNl0gIT09ICdaJykge1xuICAgICAgICAgIG9mZnNldG1pbnMgPSBwYXJzZUludChxWzhdLCAxMCkgKiA2MCArIHBhcnNlSW50KHFbOV0sIDEwKTtcbiAgICAgICAgICBpZiAocVs3XSA9PT0gJysnKSB7XG4gICAgICAgICAgICBvZmZzZXRtaW5zID0gMCAtIG9mZnNldG1pbnM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEYXRlLlVUQyhwYXJzZUludChxWzFdLCAxMCksIHBhcnNlSW50KHFbMl0sIDEwKSAtIDEsIHBhcnNlSW50KHFbM10sIDEwKSwgcGFyc2VJbnQocVs0XSwgMTApLCBwYXJzZUludChxWzVdLCAxMCkgKyBvZmZzZXRtaW5zKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHIpIHtcbiAgICAgIHNlY3MgPSBwYXJzZUZsb2F0KHJbNl0pO1xuICAgICAgaXNlY3MgPSBNYXRoLmZsb29yKHNlY3MpO1xuICAgICAgbXNlY3MgPSBNYXRoLnJvdW5kKChzZWNzIC0gaXNlY3MpICogMTAwMCk7XG4gICAgICBpZiAoIXJbOF0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHBhcnNlSW50KHJbMV0sIDEwKSwgcGFyc2VJbnQoclsyXSwgMTApIC0gMSwgcGFyc2VJbnQoclszXSwgMTApLCBwYXJzZUludChyWzRdLCAxMCksIHBhcnNlSW50KHJbNV0sIDEwKSwgaXNlY3MsIG1zZWNzKS5nZXRUaW1lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXRtaW5zID0gMDtcbiAgICAgICAgaWYgKHJbOF0gIT09ICdaJykge1xuICAgICAgICAgIG9mZnNldG1pbnMgPSBwYXJzZUludChyWzEwXSwgMTApICogNjAgKyBwYXJzZUludChyWzExXSwgMTApO1xuICAgICAgICAgIGlmIChyWzldID09PSAnKycpIHtcbiAgICAgICAgICAgIG9mZnNldG1pbnMgPSAwIC0gb2Zmc2V0bWlucztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERhdGUuVVRDKHBhcnNlSW50KHJbMV0sIDEwKSwgcGFyc2VJbnQoclsyXSwgMTApIC0gMSwgcGFyc2VJbnQoclszXSwgMTApLCBwYXJzZUludChyWzRdLCAxMCksIHBhcnNlSW50KHJbNV0sIDEwKSArIG9mZnNldG1pbnMsIGlzZWNzLCBtc2Vjcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShwYXJzZUludChkYXRlLCAxMCksIDAsIDEpLmdldFRpbWUoKTtcbiAgICB9XG4gIH07XG5cbiAgTW9ycmlzLkhvdmVyID0gKGZ1bmN0aW9uKCkge1xuICAgIEhvdmVyLmRlZmF1bHRzID0ge1xuICAgICAgXCJjbGFzc1wiOiAnbW9ycmlzLWhvdmVyIG1vcnJpcy1kZWZhdWx0LXN0eWxlJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBIb3ZlcihvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBNb3JyaXMuSG92ZXIuZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5lbCA9ICQoXCI8ZGl2IGNsYXNzPSdcIiArIHRoaXMub3B0aW9uc1tcImNsYXNzXCJdICsgXCInPjwvZGl2PlwiKTtcbiAgICAgIHRoaXMuZWwuaGlkZSgpO1xuICAgICAgdGhpcy5vcHRpb25zLnBhcmVudC5hcHBlbmQodGhpcy5lbCk7XG4gICAgfVxuXG4gICAgSG92ZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGh0bWwsIHgsIHkpIHtcbiAgICAgIGlmICghaHRtbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oaWRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmh0bWwoaHRtbCk7XG4gICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICByZXR1cm4gdGhpcy5tb3ZlVG8oeCwgeSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEhvdmVyLnByb3RvdHlwZS5odG1sID0gZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWwuaHRtbChjb250ZW50KTtcbiAgICB9O1xuXG4gICAgSG92ZXIucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHZhciBob3ZlckhlaWdodCwgaG92ZXJXaWR0aCwgbGVmdCwgcGFyZW50SGVpZ2h0LCBwYXJlbnRXaWR0aCwgdG9wO1xuICAgICAgcGFyZW50V2lkdGggPSB0aGlzLm9wdGlvbnMucGFyZW50LmlubmVyV2lkdGgoKTtcbiAgICAgIHBhcmVudEhlaWdodCA9IHRoaXMub3B0aW9ucy5wYXJlbnQuaW5uZXJIZWlnaHQoKTtcbiAgICAgIGhvdmVyV2lkdGggPSB0aGlzLmVsLm91dGVyV2lkdGgoKTtcbiAgICAgIGhvdmVySGVpZ2h0ID0gdGhpcy5lbC5vdXRlckhlaWdodCgpO1xuICAgICAgbGVmdCA9IE1hdGgubWluKE1hdGgubWF4KDAsIHggLSBob3ZlcldpZHRoIC8gMiksIHBhcmVudFdpZHRoIC0gaG92ZXJXaWR0aCk7XG4gICAgICBpZiAoeSAhPSBudWxsKSB7XG4gICAgICAgIHRvcCA9IHkgLSBob3ZlckhlaWdodCAtIDEwO1xuICAgICAgICBpZiAodG9wIDwgMCkge1xuICAgICAgICAgIHRvcCA9IHkgKyAxMDtcbiAgICAgICAgICBpZiAodG9wICsgaG92ZXJIZWlnaHQgPiBwYXJlbnRIZWlnaHQpIHtcbiAgICAgICAgICAgIHRvcCA9IHBhcmVudEhlaWdodCAvIDIgLSBob3ZlckhlaWdodCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b3AgPSBwYXJlbnRIZWlnaHQgLyAyIC0gaG92ZXJIZWlnaHQgLyAyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZWwuY3NzKHtcbiAgICAgICAgbGVmdDogbGVmdCArIFwicHhcIixcbiAgICAgICAgdG9wOiBwYXJzZUludCh0b3ApICsgXCJweFwiXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgSG92ZXIucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsLnNob3coKTtcbiAgICB9O1xuXG4gICAgSG92ZXIucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsLmhpZGUoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEhvdmVyO1xuXG4gIH0pKCk7XG5cbiAgTW9ycmlzLkxpbmUgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpbmUsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBMaW5lKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuaGlsaWdodCA9IF9fYmluZCh0aGlzLmhpbGlnaHQsIHRoaXMpO1xuICAgICAgdGhpcy5vbkhvdmVyT3V0ID0gX19iaW5kKHRoaXMub25Ib3Zlck91dCwgdGhpcyk7XG4gICAgICB0aGlzLm9uSG92ZXJNb3ZlID0gX19iaW5kKHRoaXMub25Ib3Zlck1vdmUsIHRoaXMpO1xuICAgICAgdGhpcy5vbkdyaWRDbGljayA9IF9fYmluZCh0aGlzLm9uR3JpZENsaWNrLCB0aGlzKTtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNb3JyaXMuTGluZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb3JyaXMuTGluZShvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIExpbmUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgTGluZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWRlSG92ZXIgIT09ICdhbHdheXMnKSB7XG4gICAgICAgIHRoaXMuaG92ZXIgPSBuZXcgTW9ycmlzLkhvdmVyKHtcbiAgICAgICAgICBwYXJlbnQ6IHRoaXMuZWxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oJ2hvdmVybW92ZScsIHRoaXMub25Ib3Zlck1vdmUpO1xuICAgICAgICB0aGlzLm9uKCdob3Zlcm91dCcsIHRoaXMub25Ib3Zlck91dCk7XG4gICAgICAgIHJldHVybiB0aGlzLm9uKCdncmlkY2xpY2snLCB0aGlzLm9uR3JpZENsaWNrKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgTGluZS5wcm90b3R5cGUuZGVmYXVsdHMgPSB7XG4gICAgICBsaW5lV2lkdGg6IDMsXG4gICAgICBwb2ludFNpemU6IDQsXG4gICAgICBsaW5lQ29sb3JzOiBbJyMwYjYyYTQnLCAnIzdBOTJBMycsICcjNGRhNzRkJywgJyNhZmQ4ZjgnLCAnI2VkYzI0MCcsICcjY2I0YjRiJywgJyM5NDQwZWQnXSxcbiAgICAgIHBvaW50U3Ryb2tlV2lkdGhzOiBbMV0sXG4gICAgICBwb2ludFN0cm9rZUNvbG9yczogWycjZmZmZmZmJ10sXG4gICAgICBwb2ludEZpbGxDb2xvcnM6IFtdLFxuICAgICAgc21vb3RoOiB0cnVlLFxuICAgICAgeExhYmVsczogJ2F1dG8nLFxuICAgICAgeExhYmVsRm9ybWF0OiBudWxsLFxuICAgICAgeExhYmVsTWFyZ2luOiAyNCxcbiAgICAgIGhpZGVIb3ZlcjogZmFsc2VcbiAgICB9O1xuXG4gICAgTGluZS5wcm90b3R5cGUuY2FsYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jYWxjUG9pbnRzKCk7XG4gICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVBhdGhzKCk7XG4gICAgfTtcblxuICAgIExpbmUucHJvdG90eXBlLmNhbGNQb2ludHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByb3csIHksIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgIF9yZWYgPSB0aGlzLmRhdGE7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHJvdyA9IF9yZWZbX2ldO1xuICAgICAgICByb3cuX3ggPSB0aGlzLnRyYW5zWChyb3cueCk7XG4gICAgICAgIHJvdy5feSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgX2osIF9sZW4xLCBfcmVmMSwgX3Jlc3VsdHMxO1xuICAgICAgICAgIF9yZWYxID0gcm93Lnk7XG4gICAgICAgICAgX3Jlc3VsdHMxID0gW107XG4gICAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZjEubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgICB5ID0gX3JlZjFbX2pdO1xuICAgICAgICAgICAgaWYgKHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBfcmVzdWx0czEucHVzaCh0aGlzLnRyYW5zWSh5KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfcmVzdWx0czEucHVzaCh5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzMTtcbiAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChyb3cuX3ltYXggPSBNYXRoLm1pbi5hcHBseShNYXRoLCBbdGhpcy5ib3R0b21dLmNvbmNhdCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9qLCBfbGVuMSwgX3JlZjEsIF9yZXN1bHRzMTtcbiAgICAgICAgICBfcmVmMSA9IHJvdy5feTtcbiAgICAgICAgICBfcmVzdWx0czEgPSBbXTtcbiAgICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBfcmVmMS5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICAgIHkgPSBfcmVmMVtfal07XG4gICAgICAgICAgICBpZiAoeSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIF9yZXN1bHRzMS5wdXNoKHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHMxO1xuICAgICAgICB9KSgpKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBMaW5lLnByb3RvdHlwZS5oaXRUZXN0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIGluZGV4LCByLCBfaSwgX2xlbiwgX3JlZjtcbiAgICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgX3JlZiA9IHRoaXMuZGF0YS5zbGljZSgxKTtcbiAgICAgIGZvciAoaW5kZXggPSBfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBpbmRleCA9ICsrX2kpIHtcbiAgICAgICAgciA9IF9yZWZbaW5kZXhdO1xuICAgICAgICBpZiAoeCA8IChyLl94ICsgdGhpcy5kYXRhW2luZGV4XS5feCkgLyAyKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuXG4gICAgTGluZS5wcm90b3R5cGUub25HcmlkQ2xpY2sgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB2YXIgaW5kZXg7XG4gICAgICBpbmRleCA9IHRoaXMuaGl0VGVzdCh4KTtcbiAgICAgIHJldHVybiB0aGlzLmZpcmUoJ2NsaWNrJywgaW5kZXgsIHRoaXMuZGF0YVtpbmRleF0uc3JjLCB4LCB5KTtcbiAgICB9O1xuXG4gICAgTGluZS5wcm90b3R5cGUub25Ib3Zlck1vdmUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB2YXIgaW5kZXg7XG4gICAgICBpbmRleCA9IHRoaXMuaGl0VGVzdCh4KTtcbiAgICAgIHJldHVybiB0aGlzLmRpc3BsYXlIb3ZlckZvclJvdyhpbmRleCk7XG4gICAgfTtcblxuICAgIExpbmUucHJvdG90eXBlLm9uSG92ZXJPdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGlkZUhvdmVyICE9PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5SG92ZXJGb3JSb3cobnVsbCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIExpbmUucHJvdG90eXBlLmRpc3BsYXlIb3ZlckZvclJvdyA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICB2YXIgX3JlZjtcbiAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgIChfcmVmID0gdGhpcy5ob3ZlcikudXBkYXRlLmFwcGx5KF9yZWYsIHRoaXMuaG92ZXJDb250ZW50Rm9yUm93KGluZGV4KSk7XG4gICAgICAgIHJldHVybiB0aGlzLmhpbGlnaHQoaW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ob3Zlci5oaWRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmhpbGlnaHQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgTGluZS5wcm90b3R5cGUuaG92ZXJDb250ZW50Rm9yUm93ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIHZhciBjb250ZW50LCBqLCByb3csIHksIF9pLCBfbGVuLCBfcmVmO1xuICAgICAgcm93ID0gdGhpcy5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnRlbnQgPSBcIjxkaXYgY2xhc3M9J21vcnJpcy1ob3Zlci1yb3ctbGFiZWwnPlwiICsgcm93LmxhYmVsICsgXCI8L2Rpdj5cIjtcbiAgICAgIF9yZWYgPSByb3cueTtcbiAgICAgIGZvciAoaiA9IF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IGogPSArK19pKSB7XG4gICAgICAgIHkgPSBfcmVmW2pdO1xuICAgICAgICBjb250ZW50ICs9IFwiPGRpdiBjbGFzcz0nbW9ycmlzLWhvdmVyLXBvaW50JyBzdHlsZT0nY29sb3I6IFwiICsgKHRoaXMuY29sb3JGb3Iocm93LCBqLCAnbGFiZWwnKSkgKyBcIic+XFxuICBcIiArIHRoaXMub3B0aW9ucy5sYWJlbHNbal0gKyBcIjpcXG4gIFwiICsgKHRoaXMueUxhYmVsRm9ybWF0KHkpKSArIFwiXFxuPC9kaXY+XCI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5ob3ZlckNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnRlbnQgPSB0aGlzLm9wdGlvbnMuaG92ZXJDYWxsYmFjayhpbmRleCwgdGhpcy5vcHRpb25zLCBjb250ZW50LCByb3cuc3JjKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbY29udGVudCwgcm93Ll94LCByb3cuX3ltYXhdO1xuICAgIH07XG5cbiAgICBMaW5lLnByb3RvdHlwZS5nZW5lcmF0ZVBhdGhzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29vcmRzLCBpLCByLCBzbW9vdGg7XG4gICAgICByZXR1cm4gdGhpcy5wYXRocyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaSA9IF9pID0gMCwgX3JlZiA9IHRoaXMub3B0aW9ucy55a2V5cy5sZW5ndGg7IDAgPD0gX3JlZiA/IF9pIDwgX3JlZiA6IF9pID4gX3JlZjsgaSA9IDAgPD0gX3JlZiA/ICsrX2kgOiAtLV9pKSB7XG4gICAgICAgICAgc21vb3RoID0gdHlwZW9mIHRoaXMub3B0aW9ucy5zbW9vdGggPT09IFwiYm9vbGVhblwiID8gdGhpcy5vcHRpb25zLnNtb290aCA6IChfcmVmMSA9IHRoaXMub3B0aW9ucy55a2V5c1tpXSwgX19pbmRleE9mLmNhbGwodGhpcy5vcHRpb25zLnNtb290aCwgX3JlZjEpID49IDApO1xuICAgICAgICAgIGNvb3JkcyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBfaiwgX2xlbiwgX3JlZjIsIF9yZXN1bHRzMTtcbiAgICAgICAgICAgIF9yZWYyID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgX3Jlc3VsdHMxID0gW107XG4gICAgICAgICAgICBmb3IgKF9qID0gMCwgX2xlbiA9IF9yZWYyLmxlbmd0aDsgX2ogPCBfbGVuOyBfaisrKSB7XG4gICAgICAgICAgICAgIHIgPSBfcmVmMltfal07XG4gICAgICAgICAgICAgIGlmIChyLl95W2ldICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBfcmVzdWx0czEucHVzaCh7XG4gICAgICAgICAgICAgICAgICB4OiByLl94LFxuICAgICAgICAgICAgICAgICAgeTogci5feVtpXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3Jlc3VsdHMxO1xuICAgICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICAgICAgaWYgKGNvb3Jkcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKE1vcnJpcy5MaW5lLmNyZWF0ZVBhdGgoY29vcmRzLCBzbW9vdGgsIHRoaXMuYm90dG9tKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2gobnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgfTtcblxuICAgIExpbmUucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfcmVmO1xuICAgICAgaWYgKChfcmVmID0gdGhpcy5vcHRpb25zLmF4ZXMpID09PSB0cnVlIHx8IF9yZWYgPT09ICdib3RoJyB8fCBfcmVmID09PSAneCcpIHtcbiAgICAgICAgdGhpcy5kcmF3WEF4aXMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZHJhd1NlcmllcygpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWRlSG92ZXIgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXlIb3ZlckZvclJvdyh0aGlzLmRhdGEubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIExpbmUucHJvdG90eXBlLmRyYXdYQXhpcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRyYXdMYWJlbCwgbCwgbGFiZWxzLCBwcmV2QW5nbGVNYXJnaW4sIHByZXZMYWJlbE1hcmdpbiwgcm93LCB5cG9zLCBfaSwgX2xlbiwgX3Jlc3VsdHMsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIHlwb3MgPSB0aGlzLmJvdHRvbSArIHRoaXMub3B0aW9ucy5wYWRkaW5nIC8gMjtcbiAgICAgIHByZXZMYWJlbE1hcmdpbiA9IG51bGw7XG4gICAgICBwcmV2QW5nbGVNYXJnaW4gPSBudWxsO1xuICAgICAgZHJhd0xhYmVsID0gZnVuY3Rpb24obGFiZWxUZXh0LCB4cG9zKSB7XG4gICAgICAgIHZhciBsYWJlbCwgbGFiZWxCb3gsIG1hcmdpbiwgb2Zmc2V0LCB0ZXh0Qm94O1xuICAgICAgICBsYWJlbCA9IF90aGlzLmRyYXdYQXhpc0xhYmVsKF90aGlzLnRyYW5zWCh4cG9zKSwgeXBvcywgbGFiZWxUZXh0KTtcbiAgICAgICAgdGV4dEJveCA9IGxhYmVsLmdldEJCb3goKTtcbiAgICAgICAgbGFiZWwudHJhbnNmb3JtKFwiclwiICsgKC1fdGhpcy5vcHRpb25zLnhMYWJlbEFuZ2xlKSk7XG4gICAgICAgIGxhYmVsQm94ID0gbGFiZWwuZ2V0QkJveCgpO1xuICAgICAgICBsYWJlbC50cmFuc2Zvcm0oXCJ0MCxcIiArIChsYWJlbEJveC5oZWlnaHQgLyAyKSArIFwiLi4uXCIpO1xuICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy54TGFiZWxBbmdsZSAhPT0gMCkge1xuICAgICAgICAgIG9mZnNldCA9IC0wLjUgKiB0ZXh0Qm94LndpZHRoICogTWF0aC5jb3MoX3RoaXMub3B0aW9ucy54TGFiZWxBbmdsZSAqIE1hdGguUEkgLyAxODAuMCk7XG4gICAgICAgICAgbGFiZWwudHJhbnNmb3JtKFwidFwiICsgb2Zmc2V0ICsgXCIsMC4uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBsYWJlbEJveCA9IGxhYmVsLmdldEJCb3goKTtcbiAgICAgICAgaWYgKCgocHJldkxhYmVsTWFyZ2luID09IG51bGwpIHx8IHByZXZMYWJlbE1hcmdpbiA+PSBsYWJlbEJveC54ICsgbGFiZWxCb3gud2lkdGggfHwgKHByZXZBbmdsZU1hcmdpbiAhPSBudWxsKSAmJiBwcmV2QW5nbGVNYXJnaW4gPj0gbGFiZWxCb3gueCkgJiYgbGFiZWxCb3gueCA+PSAwICYmIChsYWJlbEJveC54ICsgbGFiZWxCb3gud2lkdGgpIDwgX3RoaXMuZWwud2lkdGgoKSkge1xuICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnhMYWJlbEFuZ2xlICE9PSAwKSB7XG4gICAgICAgICAgICBtYXJnaW4gPSAxLjI1ICogX3RoaXMub3B0aW9ucy5ncmlkVGV4dFNpemUgLyBNYXRoLnNpbihfdGhpcy5vcHRpb25zLnhMYWJlbEFuZ2xlICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgICAgICAgICAgIHByZXZBbmdsZU1hcmdpbiA9IGxhYmVsQm94LnggLSBtYXJnaW47XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwcmV2TGFiZWxNYXJnaW4gPSBsYWJlbEJveC54IC0gX3RoaXMub3B0aW9ucy54TGFiZWxNYXJnaW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGxhYmVsLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wYXJzZVRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5sZW5ndGggPT09IDEgJiYgdGhpcy5vcHRpb25zLnhMYWJlbHMgPT09ICdhdXRvJykge1xuICAgICAgICAgIGxhYmVscyA9IFtbdGhpcy5kYXRhWzBdLmxhYmVsLCB0aGlzLmRhdGFbMF0ueF1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhYmVscyA9IE1vcnJpcy5sYWJlbFNlcmllcyh0aGlzLnhtaW4sIHRoaXMueG1heCwgdGhpcy53aWR0aCwgdGhpcy5vcHRpb25zLnhMYWJlbHMsIHRoaXMub3B0aW9ucy54TGFiZWxGb3JtYXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYWJlbHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgICBfcmVmID0gdGhpcy5kYXRhO1xuICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICByb3cgPSBfcmVmW19pXTtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goW3Jvdy5sYWJlbCwgcm93LnhdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgICAgbGFiZWxzLnJldmVyc2UoKTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGxhYmVscy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBsID0gbGFiZWxzW19pXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChkcmF3TGFiZWwobFswXSwgbFsxXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBMaW5lLnByb3RvdHlwZS5kcmF3U2VyaWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSwgX2ksIF9qLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICB0aGlzLnNlcmllc1BvaW50cyA9IFtdO1xuICAgICAgZm9yIChpID0gX2kgPSBfcmVmID0gdGhpcy5vcHRpb25zLnlrZXlzLmxlbmd0aCAtIDE7IF9yZWYgPD0gMCA/IF9pIDw9IDAgOiBfaSA+PSAwOyBpID0gX3JlZiA8PSAwID8gKytfaSA6IC0tX2kpIHtcbiAgICAgICAgdGhpcy5fZHJhd0xpbmVGb3IoaSk7XG4gICAgICB9XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChpID0gX2ogPSBfcmVmMSA9IHRoaXMub3B0aW9ucy55a2V5cy5sZW5ndGggLSAxOyBfcmVmMSA8PSAwID8gX2ogPD0gMCA6IF9qID49IDA7IGkgPSBfcmVmMSA8PSAwID8gKytfaiA6IC0tX2opIHtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLl9kcmF3UG9pbnRGb3IoaSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBMaW5lLnByb3RvdHlwZS5fZHJhd1BvaW50Rm9yID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIHZhciBjaXJjbGUsIHJvdywgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgdGhpcy5zZXJpZXNQb2ludHNbaW5kZXhdID0gW107XG4gICAgICBfcmVmID0gdGhpcy5kYXRhO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICByb3cgPSBfcmVmW19pXTtcbiAgICAgICAgY2lyY2xlID0gbnVsbDtcbiAgICAgICAgaWYgKHJvdy5feVtpbmRleF0gIT0gbnVsbCkge1xuICAgICAgICAgIGNpcmNsZSA9IHRoaXMuZHJhd0xpbmVQb2ludChyb3cuX3gsIHJvdy5feVtpbmRleF0sIHRoaXMuY29sb3JGb3Iocm93LCBpbmRleCwgJ3BvaW50JyksIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMuc2VyaWVzUG9pbnRzW2luZGV4XS5wdXNoKGNpcmNsZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBMaW5lLnByb3RvdHlwZS5fZHJhd0xpbmVGb3IgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgdmFyIHBhdGg7XG4gICAgICBwYXRoID0gdGhpcy5wYXRoc1tpbmRleF07XG4gICAgICBpZiAocGF0aCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3TGluZVBhdGgocGF0aCwgdGhpcy5jb2xvckZvcihudWxsLCBpbmRleCwgJ2xpbmUnKSwgaW5kZXgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBMaW5lLmNyZWF0ZVBhdGggPSBmdW5jdGlvbihjb29yZHMsIHNtb290aCwgYm90dG9tKSB7XG4gICAgICB2YXIgY29vcmQsIGcsIGdyYWRzLCBpLCBpeCwgbGcsIHBhdGgsIHByZXZDb29yZCwgeDEsIHgyLCB5MSwgeTIsIF9pLCBfbGVuO1xuICAgICAgcGF0aCA9IFwiXCI7XG4gICAgICBpZiAoc21vb3RoKSB7XG4gICAgICAgIGdyYWRzID0gTW9ycmlzLkxpbmUuZ3JhZGllbnRzKGNvb3Jkcyk7XG4gICAgICB9XG4gICAgICBwcmV2Q29vcmQgPSB7XG4gICAgICAgIHk6IG51bGxcbiAgICAgIH07XG4gICAgICBmb3IgKGkgPSBfaSA9IDAsIF9sZW4gPSBjb29yZHMubGVuZ3RoOyBfaSA8IF9sZW47IGkgPSArK19pKSB7XG4gICAgICAgIGNvb3JkID0gY29vcmRzW2ldO1xuICAgICAgICBpZiAoY29vcmQueSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHByZXZDb29yZC55ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChzbW9vdGgpIHtcbiAgICAgICAgICAgICAgZyA9IGdyYWRzW2ldO1xuICAgICAgICAgICAgICBsZyA9IGdyYWRzW2kgLSAxXTtcbiAgICAgICAgICAgICAgaXggPSAoY29vcmQueCAtIHByZXZDb29yZC54KSAvIDQ7XG4gICAgICAgICAgICAgIHgxID0gcHJldkNvb3JkLnggKyBpeDtcbiAgICAgICAgICAgICAgeTEgPSBNYXRoLm1pbihib3R0b20sIHByZXZDb29yZC55ICsgaXggKiBsZyk7XG4gICAgICAgICAgICAgIHgyID0gY29vcmQueCAtIGl4O1xuICAgICAgICAgICAgICB5MiA9IE1hdGgubWluKGJvdHRvbSwgY29vcmQueSAtIGl4ICogZyk7XG4gICAgICAgICAgICAgIHBhdGggKz0gXCJDXCIgKyB4MSArIFwiLFwiICsgeTEgKyBcIixcIiArIHgyICsgXCIsXCIgKyB5MiArIFwiLFwiICsgY29vcmQueCArIFwiLFwiICsgY29vcmQueTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhdGggKz0gXCJMXCIgKyBjb29yZC54ICsgXCIsXCIgKyBjb29yZC55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXNtb290aCB8fCAoZ3JhZHNbaV0gIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgcGF0aCArPSBcIk1cIiArIGNvb3JkLnggKyBcIixcIiArIGNvb3JkLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByZXZDb29yZCA9IGNvb3JkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcblxuICAgIExpbmUuZ3JhZGllbnRzID0gZnVuY3Rpb24oY29vcmRzKSB7XG4gICAgICB2YXIgY29vcmQsIGdyYWQsIGksIG5leHRDb29yZCwgcHJldkNvb3JkLCBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICBncmFkID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gKGEueSAtIGIueSkgLyAoYS54IC0gYi54KTtcbiAgICAgIH07XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChpID0gX2kgPSAwLCBfbGVuID0gY29vcmRzLmxlbmd0aDsgX2kgPCBfbGVuOyBpID0gKytfaSkge1xuICAgICAgICBjb29yZCA9IGNvb3Jkc1tpXTtcbiAgICAgICAgaWYgKGNvb3JkLnkgIT0gbnVsbCkge1xuICAgICAgICAgIG5leHRDb29yZCA9IGNvb3Jkc1tpICsgMV0gfHwge1xuICAgICAgICAgICAgeTogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgICAgcHJldkNvb3JkID0gY29vcmRzW2kgLSAxXSB8fCB7XG4gICAgICAgICAgICB5OiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoKHByZXZDb29yZC55ICE9IG51bGwpICYmIChuZXh0Q29vcmQueSAhPSBudWxsKSkge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChncmFkKHByZXZDb29yZCwgbmV4dENvb3JkKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmV2Q29vcmQueSAhPSBudWxsKSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGdyYWQocHJldkNvb3JkLCBjb29yZCkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENvb3JkLnkgIT0gbnVsbCkge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChncmFkKGNvb3JkLCBuZXh0Q29vcmQpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBMaW5lLnByb3RvdHlwZS5oaWxpZ2h0ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIHZhciBpLCBfaSwgX2osIF9yZWYsIF9yZWYxO1xuICAgICAgaWYgKHRoaXMucHJldkhpbGlnaHQgIT09IG51bGwgJiYgdGhpcy5wcmV2SGlsaWdodCAhPT0gaW5kZXgpIHtcbiAgICAgICAgZm9yIChpID0gX2kgPSAwLCBfcmVmID0gdGhpcy5zZXJpZXNQb2ludHMubGVuZ3RoIC0gMTsgMCA8PSBfcmVmID8gX2kgPD0gX3JlZiA6IF9pID49IF9yZWY7IGkgPSAwIDw9IF9yZWYgPyArK19pIDogLS1faSkge1xuICAgICAgICAgIGlmICh0aGlzLnNlcmllc1BvaW50c1tpXVt0aGlzLnByZXZIaWxpZ2h0XSkge1xuICAgICAgICAgICAgdGhpcy5zZXJpZXNQb2ludHNbaV1bdGhpcy5wcmV2SGlsaWdodF0uYW5pbWF0ZSh0aGlzLnBvaW50U2hyaW5rU2VyaWVzKGkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCAhPT0gbnVsbCAmJiB0aGlzLnByZXZIaWxpZ2h0ICE9PSBpbmRleCkge1xuICAgICAgICBmb3IgKGkgPSBfaiA9IDAsIF9yZWYxID0gdGhpcy5zZXJpZXNQb2ludHMubGVuZ3RoIC0gMTsgMCA8PSBfcmVmMSA/IF9qIDw9IF9yZWYxIDogX2ogPj0gX3JlZjE7IGkgPSAwIDw9IF9yZWYxID8gKytfaiA6IC0tX2opIHtcbiAgICAgICAgICBpZiAodGhpcy5zZXJpZXNQb2ludHNbaV1baW5kZXhdKSB7XG4gICAgICAgICAgICB0aGlzLnNlcmllc1BvaW50c1tpXVtpbmRleF0uYW5pbWF0ZSh0aGlzLnBvaW50R3Jvd1NlcmllcyhpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wcmV2SGlsaWdodCA9IGluZGV4O1xuICAgIH07XG5cbiAgICBMaW5lLnByb3RvdHlwZS5jb2xvckZvciA9IGZ1bmN0aW9uKHJvdywgc2lkeCwgdHlwZSkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMubGluZUNvbG9ycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxpbmVDb2xvcnMuY2FsbCh0aGlzLCByb3csIHNpZHgsIHR5cGUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAncG9pbnQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMucG9pbnRGaWxsQ29sb3JzW3NpZHggJSB0aGlzLm9wdGlvbnMucG9pbnRGaWxsQ29sb3JzLmxlbmd0aF0gfHwgdGhpcy5vcHRpb25zLmxpbmVDb2xvcnNbc2lkeCAlIHRoaXMub3B0aW9ucy5saW5lQ29sb3JzLmxlbmd0aF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxpbmVDb2xvcnNbc2lkeCAlIHRoaXMub3B0aW9ucy5saW5lQ29sb3JzLmxlbmd0aF07XG4gICAgICB9XG4gICAgfTtcblxuICAgIExpbmUucHJvdG90eXBlLmRyYXdYQXhpc0xhYmVsID0gZnVuY3Rpb24oeFBvcywgeVBvcywgdGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMucmFwaGFlbC50ZXh0KHhQb3MsIHlQb3MsIHRleHQpLmF0dHIoJ2ZvbnQtc2l6ZScsIHRoaXMub3B0aW9ucy5ncmlkVGV4dFNpemUpLmF0dHIoJ2ZvbnQtZmFtaWx5JywgdGhpcy5vcHRpb25zLmdyaWRUZXh0RmFtaWx5KS5hdHRyKCdmb250LXdlaWdodCcsIHRoaXMub3B0aW9ucy5ncmlkVGV4dFdlaWdodCkuYXR0cignZmlsbCcsIHRoaXMub3B0aW9ucy5ncmlkVGV4dENvbG9yKTtcbiAgICB9O1xuXG4gICAgTGluZS5wcm90b3R5cGUuZHJhd0xpbmVQYXRoID0gZnVuY3Rpb24ocGF0aCwgbGluZUNvbG9yLCBsaW5lSW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhcGhhZWwucGF0aChwYXRoKS5hdHRyKCdzdHJva2UnLCBsaW5lQ29sb3IpLmF0dHIoJ3N0cm9rZS13aWR0aCcsIHRoaXMubGluZVdpZHRoRm9yU2VyaWVzKGxpbmVJbmRleCkpO1xuICAgIH07XG5cbiAgICBMaW5lLnByb3RvdHlwZS5kcmF3TGluZVBvaW50ID0gZnVuY3Rpb24oeFBvcywgeVBvcywgcG9pbnRDb2xvciwgbGluZUluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5yYXBoYWVsLmNpcmNsZSh4UG9zLCB5UG9zLCB0aGlzLnBvaW50U2l6ZUZvclNlcmllcyhsaW5lSW5kZXgpKS5hdHRyKCdmaWxsJywgcG9pbnRDb2xvcikuYXR0cignc3Ryb2tlLXdpZHRoJywgdGhpcy5wb2ludFN0cm9rZVdpZHRoRm9yU2VyaWVzKGxpbmVJbmRleCkpLmF0dHIoJ3N0cm9rZScsIHRoaXMucG9pbnRTdHJva2VDb2xvckZvclNlcmllcyhsaW5lSW5kZXgpKTtcbiAgICB9O1xuXG4gICAgTGluZS5wcm90b3R5cGUucG9pbnRTdHJva2VXaWR0aEZvclNlcmllcyA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnBvaW50U3Ryb2tlV2lkdGhzW2luZGV4ICUgdGhpcy5vcHRpb25zLnBvaW50U3Ryb2tlV2lkdGhzLmxlbmd0aF07XG4gICAgfTtcblxuICAgIExpbmUucHJvdG90eXBlLnBvaW50U3Ryb2tlQ29sb3JGb3JTZXJpZXMgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wb2ludFN0cm9rZUNvbG9yc1tpbmRleCAlIHRoaXMub3B0aW9ucy5wb2ludFN0cm9rZUNvbG9ycy5sZW5ndGhdO1xuICAgIH07XG5cbiAgICBMaW5lLnByb3RvdHlwZS5saW5lV2lkdGhGb3JTZXJpZXMgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5saW5lV2lkdGggaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxpbmVXaWR0aFtpbmRleCAlIHRoaXMub3B0aW9ucy5saW5lV2lkdGgubGVuZ3RoXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGluZVdpZHRoO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBMaW5lLnByb3RvdHlwZS5wb2ludFNpemVGb3JTZXJpZXMgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wb2ludFNpemUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnBvaW50U2l6ZVtpbmRleCAlIHRoaXMub3B0aW9ucy5wb2ludFNpemUubGVuZ3RoXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMucG9pbnRTaXplO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBMaW5lLnByb3RvdHlwZS5wb2ludEdyb3dTZXJpZXMgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgcmV0dXJuIFJhcGhhZWwuYW5pbWF0aW9uKHtcbiAgICAgICAgcjogdGhpcy5wb2ludFNpemVGb3JTZXJpZXMoaW5kZXgpICsgM1xuICAgICAgfSwgMjUsICdsaW5lYXInKTtcbiAgICB9O1xuXG4gICAgTGluZS5wcm90b3R5cGUucG9pbnRTaHJpbmtTZXJpZXMgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgcmV0dXJuIFJhcGhhZWwuYW5pbWF0aW9uKHtcbiAgICAgICAgcjogdGhpcy5wb2ludFNpemVGb3JTZXJpZXMoaW5kZXgpXG4gICAgICB9LCAyNSwgJ2xpbmVhcicpO1xuICAgIH07XG5cbiAgICByZXR1cm4gTGluZTtcblxuICB9KShNb3JyaXMuR3JpZCk7XG5cbiAgTW9ycmlzLmxhYmVsU2VyaWVzID0gZnVuY3Rpb24oZG1pbiwgZG1heCwgcHh3aWR0aCwgc3BlY05hbWUsIHhMYWJlbEZvcm1hdCkge1xuICAgIHZhciBkLCBkMCwgZGRlbnNpdHksIG5hbWUsIHJldCwgcywgc3BlYywgdCwgX2ksIF9sZW4sIF9yZWY7XG4gICAgZGRlbnNpdHkgPSAyMDAgKiAoZG1heCAtIGRtaW4pIC8gcHh3aWR0aDtcbiAgICBkMCA9IG5ldyBEYXRlKGRtaW4pO1xuICAgIHNwZWMgPSBNb3JyaXMuTEFCRUxfU1BFQ1Nbc3BlY05hbWVdO1xuICAgIGlmIChzcGVjID09PSB2b2lkIDApIHtcbiAgICAgIF9yZWYgPSBNb3JyaXMuQVVUT19MQUJFTF9PUkRFUjtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBuYW1lID0gX3JlZltfaV07XG4gICAgICAgIHMgPSBNb3JyaXMuTEFCRUxfU1BFQ1NbbmFtZV07XG4gICAgICAgIGlmIChkZGVuc2l0eSA+PSBzLnNwYW4pIHtcbiAgICAgICAgICBzcGVjID0gcztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3BlYyA9PT0gdm9pZCAwKSB7XG4gICAgICBzcGVjID0gTW9ycmlzLkxBQkVMX1NQRUNTW1wic2Vjb25kXCJdO1xuICAgIH1cbiAgICBpZiAoeExhYmVsRm9ybWF0KSB7XG4gICAgICBzcGVjID0gJC5leHRlbmQoe30sIHNwZWMsIHtcbiAgICAgICAgZm10OiB4TGFiZWxGb3JtYXRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBkID0gc3BlYy5zdGFydChkMCk7XG4gICAgcmV0ID0gW107XG4gICAgd2hpbGUgKCh0ID0gZC5nZXRUaW1lKCkpIDw9IGRtYXgpIHtcbiAgICAgIGlmICh0ID49IGRtaW4pIHtcbiAgICAgICAgcmV0LnB1c2goW3NwZWMuZm10KGQpLCB0XSk7XG4gICAgICB9XG4gICAgICBzcGVjLmluY3IoZCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgbWludXRlc1NwZWNIZWxwZXIgPSBmdW5jdGlvbihpbnRlcnZhbCkge1xuICAgIHJldHVybiB7XG4gICAgICBzcGFuOiBpbnRlcnZhbCAqIDYwICogMTAwMCxcbiAgICAgIHN0YXJ0OiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIGQuZ2V0TW9udGgoKSwgZC5nZXREYXRlKCksIGQuZ2V0SG91cnMoKSk7XG4gICAgICB9LFxuICAgICAgZm10OiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgKE1vcnJpcy5wYWQyKGQuZ2V0SG91cnMoKSkpICsgXCI6XCIgKyAoTW9ycmlzLnBhZDIoZC5nZXRNaW51dGVzKCkpKTtcbiAgICAgIH0sXG4gICAgICBpbmNyOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBkLnNldFVUQ01pbnV0ZXMoZC5nZXRVVENNaW51dGVzKCkgKyBpbnRlcnZhbCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBzZWNvbmRzU3BlY0hlbHBlciA9IGZ1bmN0aW9uKGludGVydmFsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNwYW46IGludGVydmFsICogMTAwMCxcbiAgICAgIHN0YXJ0OiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIGQuZ2V0TW9udGgoKSwgZC5nZXREYXRlKCksIGQuZ2V0SG91cnMoKSwgZC5nZXRNaW51dGVzKCkpO1xuICAgICAgfSxcbiAgICAgIGZtdDogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gXCJcIiArIChNb3JyaXMucGFkMihkLmdldEhvdXJzKCkpKSArIFwiOlwiICsgKE1vcnJpcy5wYWQyKGQuZ2V0TWludXRlcygpKSkgKyBcIjpcIiArIChNb3JyaXMucGFkMihkLmdldFNlY29uZHMoKSkpO1xuICAgICAgfSxcbiAgICAgIGluY3I6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuc2V0VVRDU2Vjb25kcyhkLmdldFVUQ1NlY29uZHMoKSArIGludGVydmFsKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIE1vcnJpcy5MQUJFTF9TUEVDUyA9IHtcbiAgICBcImRlY2FkZVwiOiB7XG4gICAgICBzcGFuOiAxNzI4MDAwMDAwMDAsXG4gICAgICBzdGFydDogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpIC0gZC5nZXRGdWxsWWVhcigpICUgMTAsIDAsIDEpO1xuICAgICAgfSxcbiAgICAgIGZtdDogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gXCJcIiArIChkLmdldEZ1bGxZZWFyKCkpO1xuICAgICAgfSxcbiAgICAgIGluY3I6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuc2V0RnVsbFllYXIoZC5nZXRGdWxsWWVhcigpICsgMTApO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJ5ZWFyXCI6IHtcbiAgICAgIHNwYW46IDE3MjgwMDAwMDAwLFxuICAgICAgc3RhcnQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gICAgICB9LFxuICAgICAgZm10OiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgKGQuZ2V0RnVsbFllYXIoKSk7XG4gICAgICB9LFxuICAgICAgaW5jcjogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZC5zZXRGdWxsWWVhcihkLmdldEZ1bGxZZWFyKCkgKyAxKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwibW9udGhcIjoge1xuICAgICAgc3BhbjogMjQxOTIwMDAwMCxcbiAgICAgIHN0YXJ0OiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIGQuZ2V0TW9udGgoKSwgMSk7XG4gICAgICB9LFxuICAgICAgZm10OiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgKGQuZ2V0RnVsbFllYXIoKSkgKyBcIi1cIiArIChNb3JyaXMucGFkMihkLmdldE1vbnRoKCkgKyAxKSk7XG4gICAgICB9LFxuICAgICAgaW5jcjogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZC5zZXRNb250aChkLmdldE1vbnRoKCkgKyAxKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwid2Vla1wiOiB7XG4gICAgICBzcGFuOiA2MDQ4MDAwMDAsXG4gICAgICBzdGFydDogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCksIGQuZ2V0RGF0ZSgpKTtcbiAgICAgIH0sXG4gICAgICBmbXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIgKyAoZC5nZXRGdWxsWWVhcigpKSArIFwiLVwiICsgKE1vcnJpcy5wYWQyKGQuZ2V0TW9udGgoKSArIDEpKSArIFwiLVwiICsgKE1vcnJpcy5wYWQyKGQuZ2V0RGF0ZSgpKSk7XG4gICAgICB9LFxuICAgICAgaW5jcjogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZC5zZXREYXRlKGQuZ2V0RGF0ZSgpICsgNyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBcImRheVwiOiB7XG4gICAgICBzcGFuOiA4NjQwMDAwMCxcbiAgICAgIHN0YXJ0OiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIGQuZ2V0TW9udGgoKSwgZC5nZXREYXRlKCkpO1xuICAgICAgfSxcbiAgICAgIGZtdDogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gXCJcIiArIChkLmdldEZ1bGxZZWFyKCkpICsgXCItXCIgKyAoTW9ycmlzLnBhZDIoZC5nZXRNb250aCgpICsgMSkpICsgXCItXCIgKyAoTW9ycmlzLnBhZDIoZC5nZXREYXRlKCkpKTtcbiAgICAgIH0sXG4gICAgICBpbmNyOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBkLnNldERhdGUoZC5nZXREYXRlKCkgKyAxKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiaG91clwiOiBtaW51dGVzU3BlY0hlbHBlcig2MCksXG4gICAgXCIzMG1pblwiOiBtaW51dGVzU3BlY0hlbHBlcigzMCksXG4gICAgXCIxNW1pblwiOiBtaW51dGVzU3BlY0hlbHBlcigxNSksXG4gICAgXCIxMG1pblwiOiBtaW51dGVzU3BlY0hlbHBlcigxMCksXG4gICAgXCI1bWluXCI6IG1pbnV0ZXNTcGVjSGVscGVyKDUpLFxuICAgIFwibWludXRlXCI6IG1pbnV0ZXNTcGVjSGVscGVyKDEpLFxuICAgIFwiMzBzZWNcIjogc2Vjb25kc1NwZWNIZWxwZXIoMzApLFxuICAgIFwiMTVzZWNcIjogc2Vjb25kc1NwZWNIZWxwZXIoMTUpLFxuICAgIFwiMTBzZWNcIjogc2Vjb25kc1NwZWNIZWxwZXIoMTApLFxuICAgIFwiNXNlY1wiOiBzZWNvbmRzU3BlY0hlbHBlcig1KSxcbiAgICBcInNlY29uZFwiOiBzZWNvbmRzU3BlY0hlbHBlcigxKVxuICB9O1xuXG4gIE1vcnJpcy5BVVRPX0xBQkVMX09SREVSID0gW1wiZGVjYWRlXCIsIFwieWVhclwiLCBcIm1vbnRoXCIsIFwid2Vla1wiLCBcImRheVwiLCBcImhvdXJcIiwgXCIzMG1pblwiLCBcIjE1bWluXCIsIFwiMTBtaW5cIiwgXCI1bWluXCIsIFwibWludXRlXCIsIFwiMzBzZWNcIiwgXCIxNXNlY1wiLCBcIjEwc2VjXCIsIFwiNXNlY1wiLCBcInNlY29uZFwiXTtcblxuICBNb3JyaXMuQXJlYSA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICB2YXIgYXJlYURlZmF1bHRzO1xuXG4gICAgX19leHRlbmRzKEFyZWEsIF9zdXBlcik7XG5cbiAgICBhcmVhRGVmYXVsdHMgPSB7XG4gICAgICBmaWxsT3BhY2l0eTogJ2F1dG8nLFxuICAgICAgYmVoYXZlTGlrZUxpbmU6IGZhbHNlXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEFyZWEob3B0aW9ucykge1xuICAgICAgdmFyIGFyZWFPcHRpb25zO1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1vcnJpcy5BcmVhKSkge1xuICAgICAgICByZXR1cm4gbmV3IE1vcnJpcy5BcmVhKG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgYXJlYU9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgYXJlYURlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuY3VtdWxhdGl2ZSA9ICFhcmVhT3B0aW9ucy5iZWhhdmVMaWtlTGluZTtcbiAgICAgIGlmIChhcmVhT3B0aW9ucy5maWxsT3BhY2l0eSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIGFyZWFPcHRpb25zLmZpbGxPcGFjaXR5ID0gYXJlYU9wdGlvbnMuYmVoYXZlTGlrZUxpbmUgPyAuOCA6IDE7XG4gICAgICB9XG4gICAgICBBcmVhLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIGFyZWFPcHRpb25zKTtcbiAgICB9XG5cbiAgICBBcmVhLnByb3RvdHlwZS5jYWxjUG9pbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcm93LCB0b3RhbCwgeSwgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgX3JlZiA9IHRoaXMuZGF0YTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcm93ID0gX3JlZltfaV07XG4gICAgICAgIHJvdy5feCA9IHRoaXMudHJhbnNYKHJvdy54KTtcbiAgICAgICAgdG90YWwgPSAwO1xuICAgICAgICByb3cuX3kgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9qLCBfbGVuMSwgX3JlZjEsIF9yZXN1bHRzMTtcbiAgICAgICAgICBfcmVmMSA9IHJvdy55O1xuICAgICAgICAgIF9yZXN1bHRzMSA9IFtdO1xuICAgICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWYxLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgICAgeSA9IF9yZWYxW19qXTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmVoYXZlTGlrZUxpbmUpIHtcbiAgICAgICAgICAgICAgX3Jlc3VsdHMxLnB1c2godGhpcy50cmFuc1koeSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdG90YWwgKz0geSB8fCAwO1xuICAgICAgICAgICAgICBfcmVzdWx0czEucHVzaCh0aGlzLnRyYW5zWSh0b3RhbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHMxO1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHJvdy5feW1heCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHJvdy5feSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBBcmVhLnByb3RvdHlwZS5kcmF3U2VyaWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSwgcmFuZ2UsIF9pLCBfaiwgX2ssIF9sZW4sIF9yZWYsIF9yZWYxLCBfcmVzdWx0cywgX3Jlc3VsdHMxLCBfcmVzdWx0czI7XG4gICAgICB0aGlzLnNlcmllc1BvaW50cyA9IFtdO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5iZWhhdmVMaWtlTGluZSkge1xuICAgICAgICByYW5nZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX3JlZiA9IHRoaXMub3B0aW9ucy55a2V5cy5sZW5ndGggLSAxOyAwIDw9IF9yZWYgPyBfaSA8PSBfcmVmIDogX2kgPj0gX3JlZjsgMCA8PSBfcmVmID8gX2krKyA6IF9pLS0peyBfcmVzdWx0cy5wdXNoKF9pKTsgfVxuICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgfSkuYXBwbHkodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICBfcmVzdWx0czEgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBfaiA9IF9yZWYxID0gdGhpcy5vcHRpb25zLnlrZXlzLmxlbmd0aCAtIDE7IF9yZWYxIDw9IDAgPyBfaiA8PSAwIDogX2ogPj0gMDsgX3JlZjEgPD0gMCA/IF9qKysgOiBfai0tKXsgX3Jlc3VsdHMxLnB1c2goX2opOyB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzMTtcbiAgICAgICAgfSkuYXBwbHkodGhpcyk7XG4gICAgICB9XG4gICAgICBfcmVzdWx0czIgPSBbXTtcbiAgICAgIGZvciAoX2sgPSAwLCBfbGVuID0gcmFuZ2UubGVuZ3RoOyBfayA8IF9sZW47IF9rKyspIHtcbiAgICAgICAgaSA9IHJhbmdlW19rXTtcbiAgICAgICAgdGhpcy5fZHJhd0ZpbGxGb3IoaSk7XG4gICAgICAgIHRoaXMuX2RyYXdMaW5lRm9yKGkpO1xuICAgICAgICBfcmVzdWx0czIucHVzaCh0aGlzLl9kcmF3UG9pbnRGb3IoaSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzMjtcbiAgICB9O1xuXG4gICAgQXJlYS5wcm90b3R5cGUuX2RyYXdGaWxsRm9yID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIHZhciBwYXRoO1xuICAgICAgcGF0aCA9IHRoaXMucGF0aHNbaW5kZXhdO1xuICAgICAgaWYgKHBhdGggIT09IG51bGwpIHtcbiAgICAgICAgcGF0aCA9IHBhdGggKyAoXCJMXCIgKyAodGhpcy50cmFuc1godGhpcy54bWF4KSkgKyBcIixcIiArIHRoaXMuYm90dG9tICsgXCJMXCIgKyAodGhpcy50cmFuc1godGhpcy54bWluKSkgKyBcIixcIiArIHRoaXMuYm90dG9tICsgXCJaXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3RmlsbGVkUGF0aChwYXRoLCB0aGlzLmZpbGxGb3JTZXJpZXMoaW5kZXgpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQXJlYS5wcm90b3R5cGUuZmlsbEZvclNlcmllcyA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgIHZhciBjb2xvcjtcbiAgICAgIGNvbG9yID0gUmFwaGFlbC5yZ2IyaHNsKHRoaXMuY29sb3JGb3IodGhpcy5kYXRhW2ldLCBpLCAnbGluZScpKTtcbiAgICAgIHJldHVybiBSYXBoYWVsLmhzbChjb2xvci5oLCB0aGlzLm9wdGlvbnMuYmVoYXZlTGlrZUxpbmUgPyBjb2xvci5zICogMC45IDogY29sb3IucyAqIDAuNzUsIE1hdGgubWluKDAuOTgsIHRoaXMub3B0aW9ucy5iZWhhdmVMaWtlTGluZSA/IGNvbG9yLmwgKiAxLjIgOiBjb2xvci5sICogMS4yNSkpO1xuICAgIH07XG5cbiAgICBBcmVhLnByb3RvdHlwZS5kcmF3RmlsbGVkUGF0aCA9IGZ1bmN0aW9uKHBhdGgsIGZpbGwpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhcGhhZWwucGF0aChwYXRoKS5hdHRyKCdmaWxsJywgZmlsbCkuYXR0cignZmlsbC1vcGFjaXR5JywgdGhpcy5vcHRpb25zLmZpbGxPcGFjaXR5KS5hdHRyKCdzdHJva2UnLCAnbm9uZScpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQXJlYTtcblxuICB9KShNb3JyaXMuTGluZSk7XG5cbiAgTW9ycmlzLkJhciA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmFyLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gQmFyKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub25Ib3Zlck91dCA9IF9fYmluZCh0aGlzLm9uSG92ZXJPdXQsIHRoaXMpO1xuICAgICAgdGhpcy5vbkhvdmVyTW92ZSA9IF9fYmluZCh0aGlzLm9uSG92ZXJNb3ZlLCB0aGlzKTtcbiAgICAgIHRoaXMub25HcmlkQ2xpY2sgPSBfX2JpbmQodGhpcy5vbkdyaWRDbGljaywgdGhpcyk7XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTW9ycmlzLkJhcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb3JyaXMuQmFyKG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgQmFyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsICQuZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHBhcnNlVGltZTogZmFsc2VcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBCYXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY3VtdWxhdGl2ZSA9IHRoaXMub3B0aW9ucy5zdGFja2VkO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWRlSG92ZXIgIT09ICdhbHdheXMnKSB7XG4gICAgICAgIHRoaXMuaG92ZXIgPSBuZXcgTW9ycmlzLkhvdmVyKHtcbiAgICAgICAgICBwYXJlbnQ6IHRoaXMuZWxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oJ2hvdmVybW92ZScsIHRoaXMub25Ib3Zlck1vdmUpO1xuICAgICAgICB0aGlzLm9uKCdob3Zlcm91dCcsIHRoaXMub25Ib3Zlck91dCk7XG4gICAgICAgIHJldHVybiB0aGlzLm9uKCdncmlkY2xpY2snLCB0aGlzLm9uR3JpZENsaWNrKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQmFyLnByb3RvdHlwZS5kZWZhdWx0cyA9IHtcbiAgICAgIGJhclNpemVSYXRpbzogMC43NSxcbiAgICAgIGJhckdhcDogMyxcbiAgICAgIGJhckNvbG9yczogWycjMGI2MmE0JywgJyM3YTkyYTMnLCAnIzRkYTc0ZCcsICcjYWZkOGY4JywgJyNlZGMyNDAnLCAnI2NiNGI0YicsICcjOTQ0MGVkJ10sXG4gICAgICBiYXJPcGFjaXR5OiAxLjAsXG4gICAgICBiYXJSYWRpdXM6IFswLCAwLCAwLCAwXSxcbiAgICAgIHhMYWJlbE1hcmdpbjogNTBcbiAgICB9O1xuXG4gICAgQmFyLnByb3RvdHlwZS5jYWxjID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZjtcbiAgICAgIHRoaXMuY2FsY0JhcnMoKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGlkZUhvdmVyID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gKF9yZWYgPSB0aGlzLmhvdmVyKS51cGRhdGUuYXBwbHkoX3JlZiwgdGhpcy5ob3ZlckNvbnRlbnRGb3JSb3codGhpcy5kYXRhLmxlbmd0aCAtIDEpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQmFyLnByb3RvdHlwZS5jYWxjQmFycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlkeCwgcm93LCB5LCBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICBfcmVmID0gdGhpcy5kYXRhO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoaWR4ID0gX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgaWR4ID0gKytfaSkge1xuICAgICAgICByb3cgPSBfcmVmW2lkeF07XG4gICAgICAgIHJvdy5feCA9IHRoaXMubGVmdCArIHRoaXMud2lkdGggKiAoaWR4ICsgMC41KSAvIHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgICAgIF9yZXN1bHRzLnB1c2gocm93Ll95ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfaiwgX2xlbjEsIF9yZWYxLCBfcmVzdWx0czE7XG4gICAgICAgICAgX3JlZjEgPSByb3cueTtcbiAgICAgICAgICBfcmVzdWx0czEgPSBbXTtcbiAgICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBfcmVmMS5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICAgIHkgPSBfcmVmMVtfal07XG4gICAgICAgICAgICBpZiAoeSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIF9yZXN1bHRzMS5wdXNoKHRoaXMudHJhbnNZKHkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9yZXN1bHRzMS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHMxO1xuICAgICAgICB9KS5jYWxsKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgQmFyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZjtcbiAgICAgIGlmICgoX3JlZiA9IHRoaXMub3B0aW9ucy5heGVzKSA9PT0gdHJ1ZSB8fCBfcmVmID09PSAnYm90aCcgfHwgX3JlZiA9PT0gJ3gnKSB7XG4gICAgICAgIHRoaXMuZHJhd1hBeGlzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5kcmF3U2VyaWVzKCk7XG4gICAgfTtcblxuICAgIEJhci5wcm90b3R5cGUuZHJhd1hBeGlzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSwgbGFiZWwsIGxhYmVsQm94LCBtYXJnaW4sIG9mZnNldCwgcHJldkFuZ2xlTWFyZ2luLCBwcmV2TGFiZWxNYXJnaW4sIHJvdywgdGV4dEJveCwgeXBvcywgX2ksIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgeXBvcyA9IHRoaXMuYm90dG9tICsgKHRoaXMub3B0aW9ucy54QXhpc0xhYmVsVG9wUGFkZGluZyB8fCB0aGlzLm9wdGlvbnMucGFkZGluZyAvIDIpO1xuICAgICAgcHJldkxhYmVsTWFyZ2luID0gbnVsbDtcbiAgICAgIHByZXZBbmdsZU1hcmdpbiA9IG51bGw7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChpID0gX2kgPSAwLCBfcmVmID0gdGhpcy5kYXRhLmxlbmd0aDsgMCA8PSBfcmVmID8gX2kgPCBfcmVmIDogX2kgPiBfcmVmOyBpID0gMCA8PSBfcmVmID8gKytfaSA6IC0tX2kpIHtcbiAgICAgICAgcm93ID0gdGhpcy5kYXRhW3RoaXMuZGF0YS5sZW5ndGggLSAxIC0gaV07XG4gICAgICAgIGxhYmVsID0gdGhpcy5kcmF3WEF4aXNMYWJlbChyb3cuX3gsIHlwb3MsIHJvdy5sYWJlbCk7XG4gICAgICAgIHRleHRCb3ggPSBsYWJlbC5nZXRCQm94KCk7XG4gICAgICAgIGxhYmVsLnRyYW5zZm9ybShcInJcIiArICgtdGhpcy5vcHRpb25zLnhMYWJlbEFuZ2xlKSk7XG4gICAgICAgIGxhYmVsQm94ID0gbGFiZWwuZ2V0QkJveCgpO1xuICAgICAgICBsYWJlbC50cmFuc2Zvcm0oXCJ0MCxcIiArIChsYWJlbEJveC5oZWlnaHQgLyAyKSArIFwiLi4uXCIpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnhMYWJlbEFuZ2xlICE9PSAwKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gLTAuNSAqIHRleHRCb3gud2lkdGggKiBNYXRoLmNvcyh0aGlzLm9wdGlvbnMueExhYmVsQW5nbGUgKiBNYXRoLlBJIC8gMTgwLjApO1xuICAgICAgICAgIGxhYmVsLnRyYW5zZm9ybShcInRcIiArIG9mZnNldCArIFwiLDAuLi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgocHJldkxhYmVsTWFyZ2luID09IG51bGwpIHx8IHByZXZMYWJlbE1hcmdpbiA+PSBsYWJlbEJveC54ICsgbGFiZWxCb3gud2lkdGggfHwgKHByZXZBbmdsZU1hcmdpbiAhPSBudWxsKSAmJiBwcmV2QW5nbGVNYXJnaW4gPj0gbGFiZWxCb3gueCkgJiYgbGFiZWxCb3gueCA+PSAwICYmIChsYWJlbEJveC54ICsgbGFiZWxCb3gud2lkdGgpIDwgdGhpcy5lbC53aWR0aCgpKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy54TGFiZWxBbmdsZSAhPT0gMCkge1xuICAgICAgICAgICAgbWFyZ2luID0gMS4yNSAqIHRoaXMub3B0aW9ucy5ncmlkVGV4dFNpemUgLyBNYXRoLnNpbih0aGlzLm9wdGlvbnMueExhYmVsQW5nbGUgKiBNYXRoLlBJIC8gMTgwLjApO1xuICAgICAgICAgICAgcHJldkFuZ2xlTWFyZ2luID0gbGFiZWxCb3gueCAtIG1hcmdpbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChwcmV2TGFiZWxNYXJnaW4gPSBsYWJlbEJveC54IC0gdGhpcy5vcHRpb25zLnhMYWJlbE1hcmdpbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChsYWJlbC5yZW1vdmUoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgQmFyLnByb3RvdHlwZS5kcmF3U2VyaWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYmFyV2lkdGgsIGJvdHRvbSwgZ3JvdXBXaWR0aCwgaWR4LCBsYXN0VG9wLCBsZWZ0LCBsZWZ0UGFkZGluZywgbnVtQmFycywgcm93LCBzaWR4LCBzaXplLCBzcGFjZUxlZnQsIHRvcCwgeXBvcywgemVyb1BvcztcbiAgICAgIGdyb3VwV2lkdGggPSB0aGlzLndpZHRoIC8gdGhpcy5vcHRpb25zLmRhdGEubGVuZ3RoO1xuICAgICAgbnVtQmFycyA9IHRoaXMub3B0aW9ucy5zdGFja2VkID8gMSA6IHRoaXMub3B0aW9ucy55a2V5cy5sZW5ndGg7XG4gICAgICBiYXJXaWR0aCA9IChncm91cFdpZHRoICogdGhpcy5vcHRpb25zLmJhclNpemVSYXRpbyAtIHRoaXMub3B0aW9ucy5iYXJHYXAgKiAobnVtQmFycyAtIDEpKSAvIG51bUJhcnM7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmJhclNpemUpIHtcbiAgICAgICAgYmFyV2lkdGggPSBNYXRoLm1pbihiYXJXaWR0aCwgdGhpcy5vcHRpb25zLmJhclNpemUpO1xuICAgICAgfVxuICAgICAgc3BhY2VMZWZ0ID0gZ3JvdXBXaWR0aCAtIGJhcldpZHRoICogbnVtQmFycyAtIHRoaXMub3B0aW9ucy5iYXJHYXAgKiAobnVtQmFycyAtIDEpO1xuICAgICAgbGVmdFBhZGRpbmcgPSBzcGFjZUxlZnQgLyAyO1xuICAgICAgemVyb1BvcyA9IHRoaXMueW1pbiA8PSAwICYmIHRoaXMueW1heCA+PSAwID8gdGhpcy50cmFuc1koMCkgOiBudWxsO1xuICAgICAgcmV0dXJuIHRoaXMuYmFycyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZiA9IHRoaXMuZGF0YTtcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChpZHggPSBfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBpZHggPSArK19pKSB7XG4gICAgICAgICAgcm93ID0gX3JlZltpZHhdO1xuICAgICAgICAgIGxhc3RUb3AgPSAwO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF9qLCBfbGVuMSwgX3JlZjEsIF9yZXN1bHRzMTtcbiAgICAgICAgICAgIF9yZWYxID0gcm93Ll95O1xuICAgICAgICAgICAgX3Jlc3VsdHMxID0gW107XG4gICAgICAgICAgICBmb3IgKHNpZHggPSBfaiA9IDAsIF9sZW4xID0gX3JlZjEubGVuZ3RoOyBfaiA8IF9sZW4xOyBzaWR4ID0gKytfaikge1xuICAgICAgICAgICAgICB5cG9zID0gX3JlZjFbc2lkeF07XG4gICAgICAgICAgICAgIGlmICh5cG9zICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHplcm9Qb3MpIHtcbiAgICAgICAgICAgICAgICAgIHRvcCA9IE1hdGgubWluKHlwb3MsIHplcm9Qb3MpO1xuICAgICAgICAgICAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoeXBvcywgemVyb1Bvcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRvcCA9IHlwb3M7XG4gICAgICAgICAgICAgICAgICBib3R0b20gPSB0aGlzLmJvdHRvbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGVmdCA9IHRoaXMubGVmdCArIGlkeCAqIGdyb3VwV2lkdGggKyBsZWZ0UGFkZGluZztcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5zdGFja2VkKSB7XG4gICAgICAgICAgICAgICAgICBsZWZ0ICs9IHNpZHggKiAoYmFyV2lkdGggKyB0aGlzLm9wdGlvbnMuYmFyR2FwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2l6ZSA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnZlcnRpY2FsR3JpZENvbmRpdGlvbiAmJiB0aGlzLm9wdGlvbnMudmVydGljYWxHcmlkQ29uZGl0aW9uKHJvdy54KSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3QmFyKHRoaXMubGVmdCArIGlkeCAqIGdyb3VwV2lkdGgsIHRoaXMudG9wLCBncm91cFdpZHRoLCBNYXRoLmFicyh0aGlzLnRvcCAtIHRoaXMuYm90dG9tKSwgdGhpcy5vcHRpb25zLnZlcnRpY2FsR3JpZENvbG9yLCB0aGlzLm9wdGlvbnMudmVydGljYWxHcmlkT3BhY2l0eSwgdGhpcy5vcHRpb25zLmJhclJhZGl1cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhY2tlZCkge1xuICAgICAgICAgICAgICAgICAgdG9wIC09IGxhc3RUb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0JhcihsZWZ0LCB0b3AsIGJhcldpZHRoLCBzaXplLCB0aGlzLmNvbG9yRm9yKHJvdywgc2lkeCwgJ2JhcicpLCB0aGlzLm9wdGlvbnMuYmFyT3BhY2l0eSwgdGhpcy5vcHRpb25zLmJhclJhZGl1cyk7XG4gICAgICAgICAgICAgICAgX3Jlc3VsdHMxLnB1c2gobGFzdFRvcCArPSBzaXplKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfcmVzdWx0czEucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9yZXN1bHRzMTtcbiAgICAgICAgICB9KS5jYWxsKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KS5jYWxsKHRoaXMpO1xuICAgIH07XG5cbiAgICBCYXIucHJvdG90eXBlLmNvbG9yRm9yID0gZnVuY3Rpb24ocm93LCBzaWR4LCB0eXBlKSB7XG4gICAgICB2YXIgciwgcztcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmJhckNvbG9ycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByID0ge1xuICAgICAgICAgIHg6IHJvdy54LFxuICAgICAgICAgIHk6IHJvdy55W3NpZHhdLFxuICAgICAgICAgIGxhYmVsOiByb3cubGFiZWxcbiAgICAgICAgfTtcbiAgICAgICAgcyA9IHtcbiAgICAgICAgICBpbmRleDogc2lkeCxcbiAgICAgICAgICBrZXk6IHRoaXMub3B0aW9ucy55a2V5c1tzaWR4XSxcbiAgICAgICAgICBsYWJlbDogdGhpcy5vcHRpb25zLmxhYmVsc1tzaWR4XVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmJhckNvbG9ycy5jYWxsKHRoaXMsIHIsIHMsIHR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5iYXJDb2xvcnNbc2lkeCAlIHRoaXMub3B0aW9ucy5iYXJDb2xvcnMubGVuZ3RoXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQmFyLnByb3RvdHlwZS5oaXRUZXN0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKHRoaXMuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB4ID0gTWF0aC5tYXgoTWF0aC5taW4oeCwgdGhpcy5yaWdodCksIHRoaXMubGVmdCk7XG4gICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5kYXRhLmxlbmd0aCAtIDEsIE1hdGguZmxvb3IoKHggLSB0aGlzLmxlZnQpIC8gKHRoaXMud2lkdGggLyB0aGlzLmRhdGEubGVuZ3RoKSkpO1xuICAgIH07XG5cbiAgICBCYXIucHJvdG90eXBlLm9uR3JpZENsaWNrID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgdmFyIGluZGV4O1xuICAgICAgaW5kZXggPSB0aGlzLmhpdFRlc3QoeCk7XG4gICAgICByZXR1cm4gdGhpcy5maXJlKCdjbGljaycsIGluZGV4LCB0aGlzLmRhdGFbaW5kZXhdLnNyYywgeCwgeSk7XG4gICAgfTtcblxuICAgIEJhci5wcm90b3R5cGUub25Ib3Zlck1vdmUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB2YXIgaW5kZXgsIF9yZWY7XG4gICAgICBpbmRleCA9IHRoaXMuaGl0VGVzdCh4KTtcbiAgICAgIHJldHVybiAoX3JlZiA9IHRoaXMuaG92ZXIpLnVwZGF0ZS5hcHBseShfcmVmLCB0aGlzLmhvdmVyQ29udGVudEZvclJvdyhpbmRleCkpO1xuICAgIH07XG5cbiAgICBCYXIucHJvdG90eXBlLm9uSG92ZXJPdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGlkZUhvdmVyICE9PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3Zlci5oaWRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEJhci5wcm90b3R5cGUuaG92ZXJDb250ZW50Rm9yUm93ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIHZhciBjb250ZW50LCBqLCByb3csIHgsIHksIF9pLCBfbGVuLCBfcmVmO1xuICAgICAgcm93ID0gdGhpcy5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnRlbnQgPSBcIjxkaXYgY2xhc3M9J21vcnJpcy1ob3Zlci1yb3ctbGFiZWwnPlwiICsgcm93LmxhYmVsICsgXCI8L2Rpdj5cIjtcbiAgICAgIF9yZWYgPSByb3cueTtcbiAgICAgIGZvciAoaiA9IF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IGogPSArK19pKSB7XG4gICAgICAgIHkgPSBfcmVmW2pdO1xuICAgICAgICBjb250ZW50ICs9IFwiPGRpdiBjbGFzcz0nbW9ycmlzLWhvdmVyLXBvaW50JyBzdHlsZT0nY29sb3I6IFwiICsgKHRoaXMuY29sb3JGb3Iocm93LCBqLCAnbGFiZWwnKSkgKyBcIic+XFxuICBcIiArIHRoaXMub3B0aW9ucy5sYWJlbHNbal0gKyBcIjpcXG4gIFwiICsgKHRoaXMueUxhYmVsRm9ybWF0KHkpKSArIFwiXFxuPC9kaXY+XCI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5ob3ZlckNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnRlbnQgPSB0aGlzLm9wdGlvbnMuaG92ZXJDYWxsYmFjayhpbmRleCwgdGhpcy5vcHRpb25zLCBjb250ZW50LCByb3cuc3JjKTtcbiAgICAgIH1cbiAgICAgIHggPSB0aGlzLmxlZnQgKyAoaW5kZXggKyAwLjUpICogdGhpcy53aWR0aCAvIHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgICByZXR1cm4gW2NvbnRlbnQsIHhdO1xuICAgIH07XG5cbiAgICBCYXIucHJvdG90eXBlLmRyYXdYQXhpc0xhYmVsID0gZnVuY3Rpb24oeFBvcywgeVBvcywgdGV4dCkge1xuICAgICAgdmFyIGxhYmVsO1xuICAgICAgcmV0dXJuIGxhYmVsID0gdGhpcy5yYXBoYWVsLnRleHQoeFBvcywgeVBvcywgdGV4dCkuYXR0cignZm9udC1zaXplJywgdGhpcy5vcHRpb25zLmdyaWRUZXh0U2l6ZSkuYXR0cignZm9udC1mYW1pbHknLCB0aGlzLm9wdGlvbnMuZ3JpZFRleHRGYW1pbHkpLmF0dHIoJ2ZvbnQtd2VpZ2h0JywgdGhpcy5vcHRpb25zLmdyaWRUZXh0V2VpZ2h0KS5hdHRyKCdmaWxsJywgdGhpcy5vcHRpb25zLmdyaWRUZXh0Q29sb3IpO1xuICAgIH07XG5cbiAgICBCYXIucHJvdG90eXBlLmRyYXdCYXIgPSBmdW5jdGlvbih4UG9zLCB5UG9zLCB3aWR0aCwgaGVpZ2h0LCBiYXJDb2xvciwgb3BhY2l0eSwgcmFkaXVzQXJyYXkpIHtcbiAgICAgIHZhciBtYXhSYWRpdXMsIHBhdGg7XG4gICAgICBtYXhSYWRpdXMgPSBNYXRoLm1heC5hcHBseShNYXRoLCByYWRpdXNBcnJheSk7XG4gICAgICBpZiAobWF4UmFkaXVzID09PSAwIHx8IG1heFJhZGl1cyA+IGhlaWdodCkge1xuICAgICAgICBwYXRoID0gdGhpcy5yYXBoYWVsLnJlY3QoeFBvcywgeVBvcywgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoID0gdGhpcy5yYXBoYWVsLnBhdGgodGhpcy5yb3VuZGVkUmVjdCh4UG9zLCB5UG9zLCB3aWR0aCwgaGVpZ2h0LCByYWRpdXNBcnJheSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGguYXR0cignZmlsbCcsIGJhckNvbG9yKS5hdHRyKCdmaWxsLW9wYWNpdHknLCBvcGFjaXR5KS5hdHRyKCdzdHJva2UnLCAnbm9uZScpO1xuICAgIH07XG5cbiAgICBCYXIucHJvdG90eXBlLnJvdW5kZWRSZWN0ID0gZnVuY3Rpb24oeCwgeSwgdywgaCwgcikge1xuICAgICAgaWYgKHIgPT0gbnVsbCkge1xuICAgICAgICByID0gWzAsIDAsIDAsIDBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtcIk1cIiwgeCwgclswXSArIHksIFwiUVwiLCB4LCB5LCB4ICsgclswXSwgeSwgXCJMXCIsIHggKyB3IC0gclsxXSwgeSwgXCJRXCIsIHggKyB3LCB5LCB4ICsgdywgeSArIHJbMV0sIFwiTFwiLCB4ICsgdywgeSArIGggLSByWzJdLCBcIlFcIiwgeCArIHcsIHkgKyBoLCB4ICsgdyAtIHJbMl0sIHkgKyBoLCBcIkxcIiwgeCArIHJbM10sIHkgKyBoLCBcIlFcIiwgeCwgeSArIGgsIHgsIHkgKyBoIC0gclszXSwgXCJaXCJdO1xuICAgIH07XG5cbiAgICByZXR1cm4gQmFyO1xuXG4gIH0pKE1vcnJpcy5HcmlkKTtcblxuICBNb3JyaXMuRG9udXQgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERvbnV0LCBfc3VwZXIpO1xuXG4gICAgRG9udXQucHJvdG90eXBlLmRlZmF1bHRzID0ge1xuICAgICAgY29sb3JzOiBbJyMwQjYyQTQnLCAnIzM5ODBCNScsICcjNjc5REM2JywgJyM5NUJCRDcnLCAnI0IwQ0NFMScsICcjMDk1NzkxJywgJyMwOTUwODUnLCAnIzA4M0U2NycsICcjMDUyQzQ4JywgJyMwNDIxMzUnXSxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJyNGRkZGRkYnLFxuICAgICAgbGFiZWxDb2xvcjogJyMwMDAwMDAnLFxuICAgICAgZm9ybWF0dGVyOiBNb3JyaXMuY29tbWFzLFxuICAgICAgcmVzaXplOiBmYWxzZVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBEb251dChvcHRpb25zKSB7XG4gICAgICB0aGlzLnJlc2l6ZUhhbmRsZXIgPSBfX2JpbmQodGhpcy5yZXNpemVIYW5kbGVyLCB0aGlzKTtcbiAgICAgIHRoaXMuc2VsZWN0ID0gX19iaW5kKHRoaXMuc2VsZWN0LCB0aGlzKTtcbiAgICAgIHRoaXMuY2xpY2sgPSBfX2JpbmQodGhpcy5jbGljaywgdGhpcyk7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1vcnJpcy5Eb251dCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb3JyaXMuRG9udXQob3B0aW9ucyk7XG4gICAgICB9XG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5lbCA9ICQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0aW9ucy5lbGVtZW50KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVsID0gJChvcHRpb25zLmVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZWwgPT09IG51bGwgfHwgdGhpcy5lbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR3JhcGggcGxhY2Vob2xkZXIgbm90IGZvdW5kLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmRhdGEgPT09IHZvaWQgMCB8fCBvcHRpb25zLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucmFwaGFlbCA9IG5ldyBSYXBoYWVsKHRoaXMuZWxbMF0pO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXNpemUpIHtcbiAgICAgICAgJCh3aW5kb3cpLmJpbmQoJ3Jlc2l6ZScsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgIGlmIChfdGhpcy50aW1lb3V0SWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChfdGhpcy50aW1lb3V0SWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3RoaXMudGltZW91dElkID0gd2luZG93LnNldFRpbWVvdXQoX3RoaXMucmVzaXplSGFuZGxlciwgMTAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldERhdGEob3B0aW9ucy5kYXRhKTtcbiAgICB9XG5cbiAgICBEb251dC5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgQywgY3gsIGN5LCBpLCBpZHgsIGxhc3QsIG1heF92YWx1ZSwgbWluLCBuZXh0LCBzZWcsIHRvdGFsLCB2YWx1ZSwgdywgX2ksIF9qLCBfaywgX2xlbiwgX2xlbjEsIF9sZW4yLCBfcmVmLCBfcmVmMSwgX3JlZjIsIF9yZXN1bHRzO1xuICAgICAgdGhpcy5yYXBoYWVsLmNsZWFyKCk7XG4gICAgICBjeCA9IHRoaXMuZWwud2lkdGgoKSAvIDI7XG4gICAgICBjeSA9IHRoaXMuZWwuaGVpZ2h0KCkgLyAyO1xuICAgICAgdyA9IChNYXRoLm1pbihjeCwgY3kpIC0gMTApIC8gMztcbiAgICAgIHRvdGFsID0gMDtcbiAgICAgIF9yZWYgPSB0aGlzLnZhbHVlcztcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICB2YWx1ZSA9IF9yZWZbX2ldO1xuICAgICAgICB0b3RhbCArPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIG1pbiA9IDUgLyAoMiAqIHcpO1xuICAgICAgQyA9IDEuOTk5OSAqIE1hdGguUEkgLSBtaW4gKiB0aGlzLmRhdGEubGVuZ3RoO1xuICAgICAgbGFzdCA9IDA7XG4gICAgICBpZHggPSAwO1xuICAgICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgICAgX3JlZjEgPSB0aGlzLnZhbHVlcztcbiAgICAgIGZvciAoaSA9IF9qID0gMCwgX2xlbjEgPSBfcmVmMS5sZW5ndGg7IF9qIDwgX2xlbjE7IGkgPSArK19qKSB7XG4gICAgICAgIHZhbHVlID0gX3JlZjFbaV07XG4gICAgICAgIG5leHQgPSBsYXN0ICsgbWluICsgQyAqICh2YWx1ZSAvIHRvdGFsKTtcbiAgICAgICAgc2VnID0gbmV3IE1vcnJpcy5Eb251dFNlZ21lbnQoY3gsIGN5LCB3ICogMiwgdywgbGFzdCwgbmV4dCwgdGhpcy5kYXRhW2ldLmNvbG9yIHx8IHRoaXMub3B0aW9ucy5jb2xvcnNbaWR4ICUgdGhpcy5vcHRpb25zLmNvbG9ycy5sZW5ndGhdLCB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZENvbG9yLCBpZHgsIHRoaXMucmFwaGFlbCk7XG4gICAgICAgIHNlZy5yZW5kZXIoKTtcbiAgICAgICAgdGhpcy5zZWdtZW50cy5wdXNoKHNlZyk7XG4gICAgICAgIHNlZy5vbignaG92ZXInLCB0aGlzLnNlbGVjdCk7XG4gICAgICAgIHNlZy5vbignY2xpY2snLCB0aGlzLmNsaWNrKTtcbiAgICAgICAgbGFzdCA9IG5leHQ7XG4gICAgICAgIGlkeCArPSAxO1xuICAgICAgfVxuICAgICAgdGhpcy50ZXh0MSA9IHRoaXMuZHJhd0VtcHR5RG9udXRMYWJlbChjeCwgY3kgLSAxMCwgdGhpcy5vcHRpb25zLmxhYmVsQ29sb3IsIDE1LCA4MDApO1xuICAgICAgdGhpcy50ZXh0MiA9IHRoaXMuZHJhd0VtcHR5RG9udXRMYWJlbChjeCwgY3kgKyAxMCwgdGhpcy5vcHRpb25zLmxhYmVsQ29sb3IsIDE0KTtcbiAgICAgIG1heF92YWx1ZSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHRoaXMudmFsdWVzKTtcbiAgICAgIGlkeCA9IDA7XG4gICAgICBfcmVmMiA9IHRoaXMudmFsdWVzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2sgPSAwLCBfbGVuMiA9IF9yZWYyLmxlbmd0aDsgX2sgPCBfbGVuMjsgX2srKykge1xuICAgICAgICB2YWx1ZSA9IF9yZWYyW19rXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBtYXhfdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdChpZHgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIF9yZXN1bHRzLnB1c2goaWR4ICs9IDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBEb251dC5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciByb3c7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgdGhpcy52YWx1ZXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZWYgPSB0aGlzLmRhdGE7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHJvdyA9IF9yZWZbX2ldO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2gocGFyc2VGbG9hdChyb3cudmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXMucmVkcmF3KCk7XG4gICAgfTtcblxuICAgIERvbnV0LnByb3RvdHlwZS5jbGljayA9IGZ1bmN0aW9uKGlkeCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlyZSgnY2xpY2snLCBpZHgsIHRoaXMuZGF0YVtpZHhdKTtcbiAgICB9O1xuXG4gICAgRG9udXQucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uKGlkeCkge1xuICAgICAgdmFyIHJvdywgcywgc2VnbWVudCwgX2ksIF9sZW4sIF9yZWY7XG4gICAgICBfcmVmID0gdGhpcy5zZWdtZW50cztcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBzID0gX3JlZltfaV07XG4gICAgICAgIHMuZGVzZWxlY3QoKTtcbiAgICAgIH1cbiAgICAgIHNlZ21lbnQgPSB0aGlzLnNlZ21lbnRzW2lkeF07XG4gICAgICBzZWdtZW50LnNlbGVjdCgpO1xuICAgICAgcm93ID0gdGhpcy5kYXRhW2lkeF07XG4gICAgICByZXR1cm4gdGhpcy5zZXRMYWJlbHMocm93LmxhYmVsLCB0aGlzLm9wdGlvbnMuZm9ybWF0dGVyKHJvdy52YWx1ZSwgcm93KSk7XG4gICAgfTtcblxuICAgIERvbnV0LnByb3RvdHlwZS5zZXRMYWJlbHMgPSBmdW5jdGlvbihsYWJlbDEsIGxhYmVsMikge1xuICAgICAgdmFyIGlubmVyLCBtYXhIZWlnaHRCb3R0b20sIG1heEhlaWdodFRvcCwgbWF4V2lkdGgsIHRleHQxYmJveCwgdGV4dDFzY2FsZSwgdGV4dDJiYm94LCB0ZXh0MnNjYWxlO1xuICAgICAgaW5uZXIgPSAoTWF0aC5taW4odGhpcy5lbC53aWR0aCgpIC8gMiwgdGhpcy5lbC5oZWlnaHQoKSAvIDIpIC0gMTApICogMiAvIDM7XG4gICAgICBtYXhXaWR0aCA9IDEuOCAqIGlubmVyO1xuICAgICAgbWF4SGVpZ2h0VG9wID0gaW5uZXIgLyAyO1xuICAgICAgbWF4SGVpZ2h0Qm90dG9tID0gaW5uZXIgLyAzO1xuICAgICAgdGhpcy50ZXh0MS5hdHRyKHtcbiAgICAgICAgdGV4dDogbGFiZWwxLFxuICAgICAgICB0cmFuc2Zvcm06ICcnXG4gICAgICB9KTtcbiAgICAgIHRleHQxYmJveCA9IHRoaXMudGV4dDEuZ2V0QkJveCgpO1xuICAgICAgdGV4dDFzY2FsZSA9IE1hdGgubWluKG1heFdpZHRoIC8gdGV4dDFiYm94LndpZHRoLCBtYXhIZWlnaHRUb3AgLyB0ZXh0MWJib3guaGVpZ2h0KTtcbiAgICAgIHRoaXMudGV4dDEuYXR0cih7XG4gICAgICAgIHRyYW5zZm9ybTogXCJTXCIgKyB0ZXh0MXNjYWxlICsgXCIsXCIgKyB0ZXh0MXNjYWxlICsgXCIsXCIgKyAodGV4dDFiYm94LnggKyB0ZXh0MWJib3gud2lkdGggLyAyKSArIFwiLFwiICsgKHRleHQxYmJveC55ICsgdGV4dDFiYm94LmhlaWdodClcbiAgICAgIH0pO1xuICAgICAgdGhpcy50ZXh0Mi5hdHRyKHtcbiAgICAgICAgdGV4dDogbGFiZWwyLFxuICAgICAgICB0cmFuc2Zvcm06ICcnXG4gICAgICB9KTtcbiAgICAgIHRleHQyYmJveCA9IHRoaXMudGV4dDIuZ2V0QkJveCgpO1xuICAgICAgdGV4dDJzY2FsZSA9IE1hdGgubWluKG1heFdpZHRoIC8gdGV4dDJiYm94LndpZHRoLCBtYXhIZWlnaHRCb3R0b20gLyB0ZXh0MmJib3guaGVpZ2h0KTtcbiAgICAgIHJldHVybiB0aGlzLnRleHQyLmF0dHIoe1xuICAgICAgICB0cmFuc2Zvcm06IFwiU1wiICsgdGV4dDJzY2FsZSArIFwiLFwiICsgdGV4dDJzY2FsZSArIFwiLFwiICsgKHRleHQyYmJveC54ICsgdGV4dDJiYm94LndpZHRoIC8gMikgKyBcIixcIiArIHRleHQyYmJveC55XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgRG9udXQucHJvdG90eXBlLmRyYXdFbXB0eURvbnV0TGFiZWwgPSBmdW5jdGlvbih4UG9zLCB5UG9zLCBjb2xvciwgZm9udFNpemUsIGZvbnRXZWlnaHQpIHtcbiAgICAgIHZhciB0ZXh0O1xuICAgICAgdGV4dCA9IHRoaXMucmFwaGFlbC50ZXh0KHhQb3MsIHlQb3MsICcnKS5hdHRyKCdmb250LXNpemUnLCBmb250U2l6ZSkuYXR0cignZmlsbCcsIGNvbG9yKTtcbiAgICAgIGlmIChmb250V2VpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgdGV4dC5hdHRyKCdmb250LXdlaWdodCcsIGZvbnRXZWlnaHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIERvbnV0LnByb3RvdHlwZS5yZXNpemVIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB0aGlzLnJhcGhhZWwuc2V0U2l6ZSh0aGlzLmVsLndpZHRoKCksIHRoaXMuZWwuaGVpZ2h0KCkpO1xuICAgICAgcmV0dXJuIHRoaXMucmVkcmF3KCk7XG4gICAgfTtcblxuICAgIHJldHVybiBEb251dDtcblxuICB9KShNb3JyaXMuRXZlbnRFbWl0dGVyKTtcblxuICBNb3JyaXMuRG9udXRTZWdtZW50ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEb251dFNlZ21lbnQsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBEb251dFNlZ21lbnQoY3gsIGN5LCBpbm5lciwgb3V0ZXIsIHAwLCBwMSwgY29sb3IsIGJhY2tncm91bmRDb2xvciwgaW5kZXgsIHJhcGhhZWwpIHtcbiAgICAgIHRoaXMuY3ggPSBjeDtcbiAgICAgIHRoaXMuY3kgPSBjeTtcbiAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcbiAgICAgIHRoaXMub3V0ZXIgPSBvdXRlcjtcbiAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgdGhpcy5yYXBoYWVsID0gcmFwaGFlbDtcbiAgICAgIHRoaXMuZGVzZWxlY3QgPSBfX2JpbmQodGhpcy5kZXNlbGVjdCwgdGhpcyk7XG4gICAgICB0aGlzLnNlbGVjdCA9IF9fYmluZCh0aGlzLnNlbGVjdCwgdGhpcyk7XG4gICAgICB0aGlzLnNpbl9wMCA9IE1hdGguc2luKHAwKTtcbiAgICAgIHRoaXMuY29zX3AwID0gTWF0aC5jb3MocDApO1xuICAgICAgdGhpcy5zaW5fcDEgPSBNYXRoLnNpbihwMSk7XG4gICAgICB0aGlzLmNvc19wMSA9IE1hdGguY29zKHAxKTtcbiAgICAgIHRoaXMuaXNfbG9uZyA9IChwMSAtIHAwKSA+IE1hdGguUEkgPyAxIDogMDtcbiAgICAgIHRoaXMucGF0aCA9IHRoaXMuY2FsY1NlZ21lbnQodGhpcy5pbm5lciArIDMsIHRoaXMuaW5uZXIgKyB0aGlzLm91dGVyIC0gNSk7XG4gICAgICB0aGlzLnNlbGVjdGVkUGF0aCA9IHRoaXMuY2FsY1NlZ21lbnQodGhpcy5pbm5lciArIDMsIHRoaXMuaW5uZXIgKyB0aGlzLm91dGVyKTtcbiAgICAgIHRoaXMuaGlsaWdodCA9IHRoaXMuY2FsY0FyYyh0aGlzLmlubmVyKTtcbiAgICB9XG5cbiAgICBEb251dFNlZ21lbnQucHJvdG90eXBlLmNhbGNBcmNQb2ludHMgPSBmdW5jdGlvbihyKSB7XG4gICAgICByZXR1cm4gW3RoaXMuY3ggKyByICogdGhpcy5zaW5fcDAsIHRoaXMuY3kgKyByICogdGhpcy5jb3NfcDAsIHRoaXMuY3ggKyByICogdGhpcy5zaW5fcDEsIHRoaXMuY3kgKyByICogdGhpcy5jb3NfcDFdO1xuICAgIH07XG5cbiAgICBEb251dFNlZ21lbnQucHJvdG90eXBlLmNhbGNTZWdtZW50ID0gZnVuY3Rpb24ocjEsIHIyKSB7XG4gICAgICB2YXIgaXgwLCBpeDEsIGl5MCwgaXkxLCBveDAsIG94MSwgb3kwLCBveTEsIF9yZWYsIF9yZWYxO1xuICAgICAgX3JlZiA9IHRoaXMuY2FsY0FyY1BvaW50cyhyMSksIGl4MCA9IF9yZWZbMF0sIGl5MCA9IF9yZWZbMV0sIGl4MSA9IF9yZWZbMl0sIGl5MSA9IF9yZWZbM107XG4gICAgICBfcmVmMSA9IHRoaXMuY2FsY0FyY1BvaW50cyhyMiksIG94MCA9IF9yZWYxWzBdLCBveTAgPSBfcmVmMVsxXSwgb3gxID0gX3JlZjFbMl0sIG95MSA9IF9yZWYxWzNdO1xuICAgICAgcmV0dXJuIChcIk1cIiArIGl4MCArIFwiLFwiICsgaXkwKSArIChcIkFcIiArIHIxICsgXCIsXCIgKyByMSArIFwiLDAsXCIgKyB0aGlzLmlzX2xvbmcgKyBcIiwwLFwiICsgaXgxICsgXCIsXCIgKyBpeTEpICsgKFwiTFwiICsgb3gxICsgXCIsXCIgKyBveTEpICsgKFwiQVwiICsgcjIgKyBcIixcIiArIHIyICsgXCIsMCxcIiArIHRoaXMuaXNfbG9uZyArIFwiLDEsXCIgKyBveDAgKyBcIixcIiArIG95MCkgKyBcIlpcIjtcbiAgICB9O1xuXG4gICAgRG9udXRTZWdtZW50LnByb3RvdHlwZS5jYWxjQXJjID0gZnVuY3Rpb24ocikge1xuICAgICAgdmFyIGl4MCwgaXgxLCBpeTAsIGl5MSwgX3JlZjtcbiAgICAgIF9yZWYgPSB0aGlzLmNhbGNBcmNQb2ludHMociksIGl4MCA9IF9yZWZbMF0sIGl5MCA9IF9yZWZbMV0sIGl4MSA9IF9yZWZbMl0sIGl5MSA9IF9yZWZbM107XG4gICAgICByZXR1cm4gKFwiTVwiICsgaXgwICsgXCIsXCIgKyBpeTApICsgKFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsXCIgKyB0aGlzLmlzX2xvbmcgKyBcIiwwLFwiICsgaXgxICsgXCIsXCIgKyBpeTEpO1xuICAgIH07XG5cbiAgICBEb251dFNlZ21lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMuYXJjID0gdGhpcy5kcmF3RG9udXRBcmModGhpcy5oaWxpZ2h0LCB0aGlzLmNvbG9yKTtcbiAgICAgIHJldHVybiB0aGlzLnNlZyA9IHRoaXMuZHJhd0RvbnV0U2VnbWVudCh0aGlzLnBhdGgsIHRoaXMuY29sb3IsIHRoaXMuYmFja2dyb3VuZENvbG9yLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmZpcmUoJ2hvdmVyJywgX3RoaXMuaW5kZXgpO1xuICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5maXJlKCdjbGljaycsIF90aGlzLmluZGV4KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBEb251dFNlZ21lbnQucHJvdG90eXBlLmRyYXdEb251dEFyYyA9IGZ1bmN0aW9uKHBhdGgsIGNvbG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5yYXBoYWVsLnBhdGgocGF0aCkuYXR0cih7XG4gICAgICAgIHN0cm9rZTogY29sb3IsXG4gICAgICAgICdzdHJva2Utd2lkdGgnOiAyLFxuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgRG9udXRTZWdtZW50LnByb3RvdHlwZS5kcmF3RG9udXRTZWdtZW50ID0gZnVuY3Rpb24ocGF0aCwgZmlsbENvbG9yLCBzdHJva2VDb2xvciwgaG92ZXJGdW5jdGlvbiwgY2xpY2tGdW5jdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMucmFwaGFlbC5wYXRoKHBhdGgpLmF0dHIoe1xuICAgICAgICBmaWxsOiBmaWxsQ29sb3IsXG4gICAgICAgIHN0cm9rZTogc3Ryb2tlQ29sb3IsXG4gICAgICAgICdzdHJva2Utd2lkdGgnOiAzXG4gICAgICB9KS5ob3Zlcihob3ZlckZ1bmN0aW9uKS5jbGljayhjbGlja0Z1bmN0aW9uKTtcbiAgICB9O1xuXG4gICAgRG9udXRTZWdtZW50LnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5zZWxlY3RlZCkge1xuICAgICAgICB0aGlzLnNlZy5hbmltYXRlKHtcbiAgICAgICAgICBwYXRoOiB0aGlzLnNlbGVjdGVkUGF0aFxuICAgICAgICB9LCAxNTAsICc8PicpO1xuICAgICAgICB0aGlzLmFyYy5hbmltYXRlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgIH0sIDE1MCwgJzw+Jyk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgRG9udXRTZWdtZW50LnByb3RvdHlwZS5kZXNlbGVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5zZWcuYW5pbWF0ZSh7XG4gICAgICAgICAgcGF0aDogdGhpcy5wYXRoXG4gICAgICAgIH0sIDE1MCwgJzw+Jyk7XG4gICAgICAgIHRoaXMuYXJjLmFuaW1hdGUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSwgMTUwLCAnPD4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIERvbnV0U2VnbWVudDtcblxuICB9KShNb3JyaXMuRXZlbnRFbWl0dGVyKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsInJlcXVpcmUoJ21vcnJpcy5qcy9tb3JyaXMnKTtcbiJdfQ=="}